<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>komet &mdash; komet 1.0 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/favicon.png"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            komet
              <img src="../_static/komet-logo-small.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../vignettes/komet.html">komet : Kronecker Optimized METhod for DTI prediction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vignettes/komet_uniprotLAkernel.html">Komet with Uniprot LAkernel</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../komet.html">komet module</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">komet</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Module code</a></li>
      <li class="breadcrumb-item active">komet</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for komet</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">zipfile</span>

<span class="kn">from</span> <span class="nn">rdkit</span> <span class="kn">import</span> <span class="n">Chem</span>
<span class="kn">from</span> <span class="nn">rdkit.Chem</span> <span class="kn">import</span> <span class="n">AllChem</span>

<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">torch.optim</span> <span class="k">as</span> <span class="nn">optim</span>
<span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="n">svm</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="kn">import</span> <span class="nn">psutil</span>

<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">average_precision_score</span><span class="p">,</span> <span class="n">roc_curve</span><span class="p">,</span> <span class="n">confusion_matrix</span><span class="p">,</span> <span class="n">auc</span>

<span class="n">device</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s2">&quot;cuda:0&quot;</span> <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">()</span> <span class="k">else</span> <span class="s2">&quot;cpu&quot;</span><span class="p">)</span>
<span class="n">device_cpu</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s2">&quot;cpu&quot;</span><span class="p">)</span>
<span class="n">device_cpu</span> <span class="o">=</span> <span class="n">device</span>
<span class="nb">print</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>

<span class="n">mytype</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">float16</span>  <span class="c1"># to save memory (only on GPU)</span>
<span class="n">mytype</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">float32</span>

<div class="viewcode-block" id="load_df"><a class="viewcode-back" href="../komet.html#komet.load_df">[docs]</a><span class="k">def</span> <span class="nf">load_df</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">dataset_dir</span><span class="o">=</span><span class="s2">&quot;data&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Loads a dataframe from a CSV file, cleans up SMILES strings that cannot be read by RDKit,</span>
<span class="sd">    and returns the cleaned dataframe.</span>

<span class="sd">    :param name: The name of the file (with extension) to be loaded. If the file is a zip archive,</span>
<span class="sd">                 it will be extracted first.</span>
<span class="sd">    :type name: str</span>
<span class="sd">    :param dataset_dir: The directory where the dataset is located, by default &quot;data&quot;.</span>
<span class="sd">    :type dataset_dir: str, optional</span>
<span class="sd">    :return: The cleaned dataframe with SMILES strings that RDKit can read.</span>
<span class="sd">    :rtype: pd.DataFrame</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># if the data is in a zip file, unzip it</span>
    <span class="k">if</span> <span class="s2">&quot;.zip&quot;</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">zipfile</span><span class="o">.</span><span class="n">ZipFile</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">dataset_dir</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">zip_ref</span><span class="p">:</span>
            <span class="n">zip_ref</span><span class="o">.</span><span class="n">extractall</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">dataset_dir</span><span class="si">}</span><span class="s2">/&quot;</span><span class="p">)</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">[:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">dataset_dir</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">index_col</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># clean smiles</span>
    <span class="n">smiles</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="s1">&#39;SMILES&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">l_smiles</span> <span class="o">=</span> <span class="p">[</span><span class="n">sm</span> <span class="k">for</span> <span class="n">sm</span> <span class="ow">in</span> <span class="n">smiles</span> <span class="k">if</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">sm</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;number of smiles to clean: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">l_smiles</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="o">~</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;SMILES&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">l_smiles</span><span class="p">)]</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> shape&quot;</span><span class="p">,</span><span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span></div>

<div class="viewcode-block" id="add_indsmiles"><a class="viewcode-back" href="../komet.html#komet.add_indsmiles">[docs]</a><span class="k">def</span> <span class="nf">add_indsmiles</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adds a column to the dataframe with indices for each unique SMILES string.</span>

<span class="sd">    :param df: The dataframe to be processed.</span>
<span class="sd">    :type df: pd.DataFrame</span>
<span class="sd">    :return: A tuple containing the processed dataframe with an added column for SMILES indices</span>
<span class="sd">             and the array of unique SMILES strings.</span>
<span class="sd">    :rtype: tuple(pd.DataFrame, np.ndarray)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Index of the smiles in the dataset</span>
    <span class="n">smiles</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="s1">&#39;SMILES&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">nM</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">smiles</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;number of different smiles (mol):&quot;</span><span class="p">,</span> <span class="n">nM</span><span class="p">)</span>
    <span class="n">dict_smiles2ind</span> <span class="o">=</span> <span class="p">{</span><span class="n">smiles</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nM</span><span class="p">)}</span>
    <span class="c1"># Add indsmiles in df</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;indsmiles&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;SMILES&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">dict_smiles2ind</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;indsmiles&#39;</span><span class="p">])</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span><span class="p">,</span> <span class="n">smiles</span></div>

<div class="viewcode-block" id="Morgan_FP"><a class="viewcode-back" href="../komet.html#komet.Morgan_FP">[docs]</a><span class="k">def</span> <span class="nf">Morgan_FP</span><span class="p">(</span><span class="n">list_smiles</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the Morgan fingerprints for a list of SMILES strings.</span>

<span class="sd">    :param list_smiles: A list of SMILES strings for which to compute the fingerprints.</span>
<span class="sd">    :type list_smiles: list</span>
<span class="sd">    :return: A tensor containing the Morgan fingerprints for the input SMILES strings.</span>
<span class="sd">    :rtype: torch.Tensor</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ms</span> <span class="o">=</span> <span class="p">[</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">sm</span><span class="p">)</span> <span class="k">for</span> <span class="n">sm</span> <span class="ow">in</span> <span class="n">list_smiles</span><span class="p">]</span>
    <span class="n">nM</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ms</span><span class="p">)</span>
    <span class="n">MorganFP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nM</span><span class="p">,</span> <span class="mi">1024</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nM</span><span class="p">):</span>
        <span class="c1"># Generate Morgan fingerprint of the molecule</span>
        <span class="n">fp</span> <span class="o">=</span> <span class="n">AllChem</span><span class="o">.</span><span class="n">GetMorganFingerprintAsBitVect</span><span class="p">(</span><span class="n">ms</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">2</span><span class="p">,</span> <span class="n">nBits</span><span class="o">=</span><span class="mi">1024</span><span class="p">)</span>
        <span class="c1"># Convert the fingerprint to a numpy array</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,))</span>
        <span class="n">AllChem</span><span class="o">.</span><span class="n">DataStructs</span><span class="o">.</span><span class="n">ConvertToNumpyArray</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">arr</span><span class="p">)</span>
        <span class="n">MorganFP</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">arr</span>
    <span class="n">MorganFP</span> <span class="o">=</span> <span class="n">MorganFP</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">MorganFP</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">MorganFP</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">mytype</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">MorganFP</span></div>

<div class="viewcode-block" id="Nystrom_X_cn"><a class="viewcode-back" href="../komet.html#komet.Nystrom_X_cn">[docs]</a><span class="k">def</span> <span class="nf">Nystrom_X_cn</span><span class="p">(</span><span class="n">mM</span><span class="p">,</span><span class="n">rM</span><span class="p">,</span><span class="n">nM</span><span class="p">,</span><span class="n">MorganFP</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Nystrom approximation of the centered normalized feature matrix.</span>

<span class="sd">    :param mM: Number of molecule landmarks</span>
<span class="sd">    :type mM: int</span>
<span class="sd">    :param rM: Number of dimensions to keep after SVD for molecule features</span>
<span class="sd">    :type rM: int</span>
<span class="sd">    :param nM: Total number of molecules.</span>
<span class="sd">    :type nM: int</span>
<span class="sd">    :param MorganFP: Matrix of Morgan fingerprints of shape (nM, fingerprint_length).</span>
<span class="sd">    :type MorganFP: numpy.ndarray</span>
<span class="sd">    :return: The centered normalized feature matrix.</span>
<span class="sd">    :rtype: torch.Tensor</span>
<span class="sd">    :notes: This function computes the Nystrom approximation of the feature matrix using the given</span>
<span class="sd">            Morgan fingerprints. It first selects a random subset S of size mM from the total</span>
<span class="sd">            nM molecules. It then computes the kernel matrix K using the selected subset.</span>
<span class="sd">            The approximate feature matrix is computed using Singular Value Decomposition (SVD)</span>
<span class="sd">            on K. Finally, the features are normalized by centering and dividing by their L2 norm.</span>

<span class="sd">            The input MorganFP should be a numpy array with shape (nM, fingerprint_length).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">nM</span><span class="p">)[:</span><span class="n">mM</span><span class="p">]</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
    <span class="n">K</span> <span class="o">=</span> <span class="p">(</span> <span class="n">MorganFP</span><span class="p">[</span><span class="n">S</span><span class="p">,:]</span> <span class="o">@</span> <span class="n">MorganFP</span><span class="o">.</span><span class="n">T</span> <span class="p">)</span> <span class="o">/</span> <span class="p">(</span> <span class="mi">1024</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">MorganFP</span><span class="p">[</span><span class="n">S</span><span class="p">,:])</span> <span class="o">@</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">MorganFP</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;mol kernel shape&quot;</span><span class="p">,</span><span class="n">K</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="c1"># compute the approximate mol features with SVD</span>
    <span class="n">U</span><span class="p">,</span> <span class="n">Lambda</span><span class="p">,</span> <span class="n">VT</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">K</span><span class="p">[:,</span><span class="n">S</span><span class="p">])</span>
    <span class="n">epsi</span> <span class="o">=</span> <span class="mf">1e-8</span>  <span class="c1"># be careful when we divide by Lambda near 0</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">U</span><span class="p">[:,:</span><span class="n">rM</span><span class="p">]</span> <span class="o">@</span> <span class="n">torch</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="n">torch</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">epsi</span> <span class="o">+</span> <span class="n">Lambda</span><span class="p">[:</span><span class="n">rM</span><span class="p">]))</span>
    <span class="c1"># nomramlisation of the features</span>
    <span class="n">X_c</span> <span class="o">=</span> <span class="n">X</span> <span class="o">-</span> <span class="n">X</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">X_cn</span> <span class="o">=</span> <span class="n">X_c</span> <span class="o">/</span> <span class="n">torch</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">X_c</span><span class="p">,</span><span class="n">dim</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">X_cn</span></div>

<div class="viewcode-block" id="Nystrom_X"><a class="viewcode-back" href="../komet.html#komet.Nystrom_X">[docs]</a><span class="k">def</span> <span class="nf">Nystrom_X</span><span class="p">(</span><span class="n">smiles_list</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">MorganFP</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">rM</span><span class="p">,</span> <span class="n">Mu</span><span class="p">,</span> <span class="n">epsi</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the approximate features of the molecular kernel using the Nystrom approximation.</span>

<span class="sd">    :param smiles_list: A list of SMILES strings for which to compute features.</span>
<span class="sd">    :param S: Indices of the subset of samples used for the Nystrom approximation.</span>
<span class="sd">    :param MorganFP: Precomputed Morgan Fingerprints for the dataset.</span>
<span class="sd">    :param V: Eigenvectors of the kernel matrix.</span>
<span class="sd">    :param rM: Rank of the approximation.</span>
<span class="sd">    :param Mu: Eigenvalues of the kernel matrix.</span>
<span class="sd">    :param epsi: Small regularization term added for numerical stability.</span>
<span class="sd">    :return: Approximated feature matrix for the input SMILES list.</span>
<span class="sd">    :rtype: torch.Tensor</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Compute Morgan fingerprints for the input list of SMILES</span>
    <span class="n">MorganFP_list</span> <span class="o">=</span> <span class="n">Morgan_FP</span><span class="p">(</span><span class="n">smiles_list</span><span class="p">)</span>

    <span class="c1"># Compute the Nystrom approximation of the molecular kernel and the features</span>
    <span class="n">Z_list</span> <span class="o">=</span> <span class="p">(</span><span class="n">MorganFP</span><span class="p">[</span><span class="n">S</span><span class="p">,</span> <span class="p">:]</span> <span class="o">@</span> <span class="n">MorganFP_list</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1024</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">MorganFP</span><span class="p">[</span><span class="n">S</span><span class="p">,</span> <span class="p">:])</span> <span class="o">@</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">MorganFP_list</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Z_list shape&quot;</span><span class="p">,</span> <span class="n">Z_list</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="n">X_list</span> <span class="o">=</span> <span class="n">Z_list</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">V</span><span class="p">[:,</span> <span class="p">:</span><span class="n">rM</span><span class="p">]</span> <span class="o">@</span> <span class="n">torch</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">torch</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">epsi</span> <span class="o">+</span> <span class="n">Mu</span><span class="p">[:</span><span class="n">rM</span><span class="p">]))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;mol features list shape&quot;</span><span class="p">,</span> <span class="n">X_list</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">X_list</span></div>

<div class="viewcode-block" id="add_indfasta"><a class="viewcode-back" href="../komet.html#komet.add_indfasta">[docs]</a><span class="k">def</span> <span class="nf">add_indfasta</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adds an index column for each unique FASTA sequence in the dataframe.</span>

<span class="sd">    :param df: Dataframe containing protein sequences.</span>
<span class="sd">    :return: The updated dataframe with an &#39;indfasta&#39; column and the array of unique FASTA sequences.</span>
<span class="sd">    :rtype: tuple[pd.DataFrame, np.ndarray]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Index of the protein in the dataset</span>
    <span class="n">fasta</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="s1">&#39;Target Sequence&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;number of different Fasta (protein):&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">fasta</span><span class="p">))</span>
    <span class="c1"># Add ind_fasta in the dataframe</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;indfasta&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;Target Sequence&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">fasta</span> <span class="o">==</span> <span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">df</span><span class="p">,</span> <span class="n">fasta</span></div>

<div class="viewcode-block" id="load_datas"><a class="viewcode-back" href="../komet.html#komet.load_datas">[docs]</a><span class="k">def</span> <span class="nf">load_datas</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Loads interaction data including indices of molecule and protein pairs along with their labels.</span>

<span class="sd">    :param df: Dataframe containing the interaction data.</span>
<span class="sd">    :return: Tensors of molecule indices, protein indices, and interaction labels.</span>
<span class="sd">    :rtype: tuple[torch.Tensor, torch.Tensor, torch.Tensor]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">array_df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="s1">&#39;indfasta&#39;</span><span class="p">,</span> <span class="s1">&#39;indsmiles&#39;</span><span class="p">,</span> <span class="s1">&#39;Label&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
    <span class="c1"># Extract indices for proteins, molecules, and labels</span>
    <span class="n">J</span> <span class="o">=</span> <span class="n">array_df</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># proteins</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">array_df</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># molecules</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">array_df</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>  <span class="c1"># labels</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">long</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    <span class="n">J</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">long</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="mf">.5</span><span class="p">))</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">I</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">y</span></div>

<div class="viewcode-block" id="SVM_bfgs"><a class="viewcode-back" href="../komet.html#komet.SVM_bfgs">[docs]</a><span class="k">def</span> <span class="nf">SVM_bfgs</span><span class="p">(</span><span class="n">X_cn</span><span class="p">,</span> <span class="n">Y_cn</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">lamb</span><span class="p">,</span><span class="n">niter</span> <span class="o">=</span> <span class="mi">50</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Trains an SVM model using the L-BFGS optimization algorithm to minimize the loss function.</span>

<span class="sd">    :param X_cn: Feature matrix for compounds.</span>
<span class="sd">    :param Y_cn: Feature matrix for targets.</span>
<span class="sd">    :param y: Interaction labels.</span>
<span class="sd">    :param I: Indices of molecules.</span>
<span class="sd">    :param J: Indices of proteins.</span>
<span class="sd">    :param lamb: Regularization parameter.</span>
<span class="sd">    :param niter: Number of iterations for the L-BFGS optimization algorithm.</span>
<span class="sd">    :return: Optimized weight and bias parameters for the SVM model, and the history of the loss function.</span>
<span class="sd">    :rtype: tuple[torch.Tensor, torch.Tensor, list[float]]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
    <span class="n">XI</span> <span class="o">=</span> <span class="n">X_cn</span><span class="p">[</span><span class="n">I</span><span class="p">,</span> <span class="p">:]</span>
    <span class="k">def</span> <span class="nf">U</span><span class="p">(</span><span class="n">w</span><span class="p">):</span> <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">Y_cn</span> <span class="o">@</span> <span class="n">w</span><span class="p">)[</span><span class="n">J</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">XI</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># FAST</span>

    <span class="k">def</span> <span class="nf">Loss</span><span class="p">(</span><span class="n">u</span><span class="p">):</span> <span class="k">return</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">n</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">u</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span>  <span class="c1"># Loss function</span>
    <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span> <span class="k">return</span> <span class="n">Loss</span><span class="p">(</span><span class="o">-</span><span class="n">y</span> <span class="o">*</span> <span class="p">(</span><span class="n">U</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">+</span> <span class="n">b</span><span class="p">))</span> <span class="o">+</span> <span class="n">lamb</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">w</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>  <span class="c1"># Function to minimize</span>

    <span class="c1"># L-BFGS optimization</span>
    <span class="k">def</span> <span class="nf">closure</span><span class="p">():</span>
        <span class="n">lbfgs</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>
        <span class="n">objective</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">w_bfgs</span><span class="p">,</span> <span class="n">b_bfgs</span><span class="p">)</span>
        <span class="n">objective</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">objective</span>

    <span class="n">rM</span> <span class="o">=</span> <span class="n">X_cn</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">rP</span> <span class="o">=</span> <span class="n">Y_cn</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">w_bfgs</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">rP</span><span class="p">,</span> <span class="n">rM</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    <span class="n">b_bfgs</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    <span class="n">w_bfgs</span><span class="o">.</span><span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">b_bfgs</span><span class="o">.</span><span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">lbfgs</span> <span class="o">=</span> <span class="n">optim</span><span class="o">.</span><span class="n">LBFGS</span><span class="p">([</span><span class="n">w_bfgs</span><span class="p">,</span> <span class="n">b_bfgs</span><span class="p">],</span> <span class="n">history_size</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">line_search_fn</span><span class="o">=</span><span class="s2">&quot;strong_wolfe&quot;</span><span class="p">)</span>
    
    <span class="n">history_lbfgs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">niter</span><span class="p">):</span>
        <span class="n">history_lbfgs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="n">w_bfgs</span><span class="p">,</span> <span class="n">b_bfgs</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>
        <span class="n">lbfgs</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">closure</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;L-BFGS time: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">tic</span><span class="si">:</span><span class="s2">0.4f</span><span class="si">}</span><span class="s2"> seconds&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">w_bfgs</span><span class="p">,</span> <span class="n">b_bfgs</span><span class="p">,</span><span class="n">history_lbfgs</span></div>

<div class="viewcode-block" id="compute_proba_Platt_Scalling"><a class="viewcode-back" href="../komet.html#komet.compute_proba_Platt_Scalling">[docs]</a><span class="k">def</span> <span class="nf">compute_proba_Platt_Scalling</span><span class="p">(</span><span class="n">w_bfgs</span><span class="p">,</span> <span class="n">X_cn</span><span class="p">,</span> <span class="n">Y_cn</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span><span class="n">niter</span> <span class="o">=</span> <span class="mi">20</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes probability estimates for interaction predictions using Platt scaling.</span>

<span class="sd">    :param w_bfgs: Optimized weights from the SVM model.</span>
<span class="sd">    :param X_cn: Feature matrix for compounds.</span>
<span class="sd">    :param Y_cn: Feature matrix for targets.</span>
<span class="sd">    :param y: Interaction labels.</span>
<span class="sd">    :param I: Indices of molecules.</span>
<span class="sd">    :param J: Indices of proteins.</span>
<span class="sd">    :param niter: Number of iterations for the L-BFGS optimization algorithm.</span>
<span class="sd">    :return: Optimized parameters &#39;s&#39; and &#39;t&#39; for Platt scaling, and the history of the loss function.</span>
<span class="sd">    :rtype: tuple[torch.Tensor, torch.Tensor,list[float]]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
    <span class="n">XI</span> <span class="o">=</span> <span class="n">X_cn</span><span class="p">[</span><span class="n">I</span><span class="p">,</span> <span class="p">:]</span>
    <span class="k">def</span> <span class="nf">U</span><span class="p">(</span><span class="n">w</span><span class="p">):</span> <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">Y_cn</span> <span class="o">@</span> <span class="n">w</span><span class="p">)[</span><span class="n">J</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">XI</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># FAST</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">U</span><span class="p">(</span><span class="n">w_bfgs</span><span class="p">)</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>  <span class="c1"># Detach to stop backpropagation</span>

    <span class="c1"># Logistic regression to find &#39;s&#39; and &#39;t&#39;</span>
    <span class="k">def</span> <span class="nf">E</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span> <span class="k">return</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">n</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">y</span> <span class="o">*</span> <span class="p">(</span><span class="n">s</span> <span class="o">*</span> <span class="n">m</span> <span class="o">+</span> <span class="n">t</span><span class="p">))))</span>

    <span class="c1"># L-BFGS optimization</span>
    <span class="k">def</span> <span class="nf">closure</span><span class="p">():</span>
        <span class="n">lbfgs</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>
        <span class="n">objective</span> <span class="o">=</span> <span class="n">E</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
        <span class="n">objective</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">objective</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    <span class="n">s</span><span class="o">.</span><span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">t</span><span class="o">.</span><span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">lbfgs</span> <span class="o">=</span> <span class="n">optim</span><span class="o">.</span><span class="n">LBFGS</span><span class="p">([</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">],</span> <span class="n">history_size</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">line_search_fn</span><span class="o">=</span><span class="s2">&quot;strong_wolfe&quot;</span><span class="p">)</span>

    <span class="n">history_lbfgs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">niter</span><span class="p">):</span>
        <span class="n">history_lbfgs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">E</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>
        <span class="n">lbfgs</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">closure</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span><span class="n">history_lbfgs</span></div>


<div class="viewcode-block" id="compute_proba"><a class="viewcode-back" href="../komet.html#komet.compute_proba">[docs]</a><span class="k">def</span> <span class="nf">compute_proba</span><span class="p">(</span><span class="n">w_bfgs</span><span class="p">,</span> <span class="n">b_bfgs</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">X_cn</span><span class="p">,</span> <span class="n">Y_cn</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">J</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes probabilities using the trained weights and Platt scaling parameters.</span>

<span class="sd">    :param w_bfgs: Optimized weights from the SVM model for compounds.</span>
<span class="sd">    :param b_bfgs: Optimized bias from the SVM model.</span>
<span class="sd">    :param s: Optimized scaling parameter from Platt scaling.</span>
<span class="sd">    :param t: Optimized offset parameter from Platt scaling.</span>
<span class="sd">    :param X_cn: Feature matrix for compounds.</span>
<span class="sd">    :param Y_cn: Feature matrix for targets.</span>
<span class="sd">    :param I: Indices of molecules.</span>
<span class="sd">    :param J: Indices of proteins.</span>
<span class="sd">    :return: A tuple containing the margin values, predicted labels, and predicted probabilities.</span>
<span class="sd">    :rtype: tuple[torch.Tensor, torch.Tensor, torch.Tensor]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">Y_cn</span> <span class="o">@</span> <span class="n">w_bfgs</span><span class="p">)[</span><span class="n">J</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">X_cn</span><span class="p">[</span><span class="n">I</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Margin computation</span>
    <span class="n">y_pred</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="n">b_bfgs</span><span class="p">)</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>  <span class="c1"># Label prediction</span>
    <span class="n">proba_pred</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">s</span> <span class="o">*</span> <span class="n">m</span> <span class="o">+</span> <span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>  <span class="c1"># Probability prediction</span>
    <span class="k">return</span> <span class="n">m</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">proba_pred</span></div>

<div class="viewcode-block" id="results"><a class="viewcode-back" href="../komet.html#komet.results">[docs]</a><span class="k">def</span> <span class="nf">results</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">proba_pred</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes and returns various performance metrics of the model including accuracy, AUC, average precision,</span>
<span class="sd">    optimal threshold for classification, accuracy at the best threshold, confusion matrix, and false positive rate.</span>

<span class="sd">    :param y: True labels.</span>
<span class="sd">    :param y_pred: Predicted labels before applying Platt scaling.</span>
<span class="sd">    :param proba_pred: Predicted probabilities after applying Platt scaling.</span>
<span class="sd">    :return: A tuple containing accuracy before Platt scaling, AUC, average precision, optimal threshold,</span>
<span class="sd">             accuracy at optimal threshold, confusion matrix, and false positive rate at the optimal threshold.</span>
<span class="sd">    :rtype: tuple[float, float, float, float, float, np.ndarray, float]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Accuracy before Platt scaling</span>
    <span class="n">acc1</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="n">y_pred</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

    <span class="c1"># AUC computation</span>
    <span class="n">fpr</span><span class="p">,</span> <span class="n">tpr</span><span class="p">,</span> <span class="n">thresholds</span> <span class="o">=</span> <span class="n">roc_curve</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span> <span class="n">proba_pred</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>
    <span class="n">au_Roc</span> <span class="o">=</span> <span class="n">auc</span><span class="p">(</span><span class="n">fpr</span><span class="p">,</span> <span class="n">tpr</span><span class="p">)</span>

    <span class="c1"># Average precision computation</span>
    <span class="n">au_PR</span> <span class="o">=</span> <span class="n">average_precision_score</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span> <span class="n">proba_pred</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>

    <span class="c1"># Optimal threshold for classification</span>
    <span class="n">precision</span> <span class="o">=</span> <span class="n">tpr</span> <span class="o">/</span> <span class="p">(</span><span class="n">tpr</span> <span class="o">+</span> <span class="n">fpr</span> <span class="o">+</span> <span class="mf">0.00001</span><span class="p">)</span>
    <span class="n">f1</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">precision</span> <span class="o">*</span> <span class="n">tpr</span> <span class="o">/</span> <span class="p">(</span><span class="n">tpr</span> <span class="o">+</span> <span class="n">precision</span> <span class="o">+</span> <span class="mf">0.00001</span><span class="p">)</span>
    <span class="n">thred_optim</span> <span class="o">=</span> <span class="n">thresholds</span><span class="p">[</span><span class="mi">5</span><span class="p">:][</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">f1</span><span class="p">[</span><span class="mi">5</span><span class="p">:])]</span>

    <span class="c1"># Accuracy at the optimal threshold</span>
    <span class="n">y_pred_s</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="k">if</span> <span class="n">i</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="n">proba_pred</span> <span class="o">&gt;=</span> <span class="n">thred_optim</span><span class="p">)]</span>
    <span class="n">acc_best</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">y_pred_s</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">device</span><span class="p">))</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

    <span class="c1"># Confusion matrix computation</span>
    <span class="n">cm</span> <span class="o">=</span> <span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span> <span class="n">y_pred_s</span><span class="p">)</span>

    <span class="c1"># False positive rate at the optimal threshold</span>
    <span class="n">FP</span> <span class="o">=</span> <span class="n">cm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">cm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">cm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">acc1</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span> <span class="n">au_Roc</span><span class="p">,</span> <span class="n">au_PR</span><span class="p">,</span> <span class="n">thred_optim</span><span class="p">,</span> <span class="n">acc_best</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span> <span class="n">cm</span><span class="p">,</span> <span class="n">FP</span></div>

 
<div class="viewcode-block" id="make_train_test_val_S1"><a class="viewcode-back" href="../komet.html#komet.make_train_test_val_S1">[docs]</a><span class="k">def</span> <span class="nf">make_train_test_val_S1</span><span class="p">(</span><span class="n">df</span><span class="p">,</span><span class="n">train_ratio</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span><span class="n">test_ratio</span><span class="o">=</span><span class="mf">0.12</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Splits the input DataFrame into training, testing, and validation datasets. The function first converts the DataFrame into a </span>
<span class="sd">    numpy matrix where rows correspond to &#39;indfasta&#39; (protein indices), columns to &#39;indsmiles&#39; (drug indices), and cell values to &#39;score&#39; (interaction score).</span>
<span class="sd">    It then identifies positive (interaction score = 1) and negative (interaction score = 0) interactions and distributes them into </span>
<span class="sd">    training, testing, and validation sets according to the specified ratios. The split is done ensuring that each set contains a </span>
<span class="sd">    balanced proportion of positive and unknown interactions.</span>

<span class="sd">    :param df: Input data containing the columns &#39;indfasta&#39;, &#39;indsmiles&#39;, and &#39;score&#39;.</span>
<span class="sd">    :type df: pandas.DataFrame</span>
<span class="sd">    :param train_ratio: The proportion of the dataset to be used for the training set, defaults to 0.8.</span>
<span class="sd">    :type train_ratio: float, optional</span>
<span class="sd">    :param test_ratio: The proportion of the dataset to be used for the testing set, defaults to 0.12.</span>
<span class="sd">    :type test_ratio: float, optional</span>
<span class="sd">    :return: A tuple of numpy arrays representing the training, testing, and validation datasets respectively.</span>
<span class="sd">    :rtype: (numpy.ndarray, numpy.ndarray, numpy.ndarray)</span>

<span class="sd">    Note:</span>
<span class="sd">    The remaining portion of the dataset not allocated to training or testing is used for validation.</span>
<span class="sd">    This function assumes that the DataFrame&#39;s &#39;score&#39; column contains binary values (1 for interaction and 0 for no interaction).</span>
<span class="sd">    NaN values in &#39;score&#39; are treated as unknown interactions and are handled separately.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">try</span> <span class="p">:</span> 
        <span class="n">intMat</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">pivot</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="s1">&#39;indfasta&#39;</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="s2">&quot;indsmiles&quot;</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="s1">&#39;score&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float16</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">intMat</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">pivot_table</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="s1">&#39;indfasta&#39;</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="s2">&quot;indsmiles&quot;</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="s1">&#39;score&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float16</span><span class="p">)</span>

    <span class="n">n_p</span><span class="p">,</span><span class="n">n_m</span> <span class="o">=</span> <span class="n">intMat</span><span class="o">.</span><span class="n">shape</span> <span class="c1"># number of proteins and drugs</span>
    <span class="n">Ip</span><span class="p">,</span> <span class="n">Jm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">intMat</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># indices of interactions +</span>
    <span class="n">nb_positive_inter</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Ip</span><span class="p">))</span>
    <span class="n">Inp</span><span class="p">,</span> <span class="n">Jnm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">intMat</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">Inkp</span><span class="p">,</span> <span class="n">Jnkm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">intMat</span><span class="p">))</span>

    <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">nb_positive_inter</span><span class="p">)</span> <span class="c1"># shuffle the indices of interactions +</span>
    <span class="n">train_index</span> <span class="o">=</span> <span class="n">S</span><span class="p">[:</span><span class="nb">int</span><span class="p">(</span><span class="n">train_ratio</span><span class="o">*</span><span class="n">nb_positive_inter</span><span class="p">)]</span>
    <span class="n">test_index</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">train_ratio</span><span class="o">*</span><span class="n">nb_positive_inter</span><span class="p">):</span><span class="nb">int</span><span class="p">((</span><span class="n">train_ratio</span><span class="o">+</span><span class="n">test_ratio</span><span class="p">)</span><span class="o">*</span><span class="n">nb_positive_inter</span><span class="p">)]</span>
    <span class="n">val_index</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="nb">int</span><span class="p">((</span><span class="n">train_ratio</span><span class="o">+</span><span class="n">test_ratio</span><span class="p">)</span><span class="o">*</span><span class="n">nb_positive_inter</span><span class="p">):]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;train&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">train_index</span><span class="p">),</span> <span class="s2">&quot;test&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">test_index</span><span class="p">),</span> <span class="s2">&quot;val&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">val_index</span><span class="p">))</span>

    <span class="c1">#### TRAIN ####</span>
    <span class="n">Mm</span><span class="p">,</span> <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">Ip</span><span class="p">[</span><span class="n">train_index</span><span class="p">],</span> <span class="n">bins</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_p</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="c1"># np.array with  #interactions for each protein of the train at the beginning</span>

    <span class="n">Mp</span><span class="p">,</span> <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">Jm</span><span class="p">[</span><span class="n">train_index</span><span class="p">],</span> <span class="n">bins</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_m</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="c1"># np.array with  #interactions for each drugs at the beginning (how manu time it can be chosen)</span>

    <span class="n">train</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="n">nb_prot</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">Ip</span><span class="p">[</span><span class="n">train_index</span><span class="p">])))</span> <span class="c1"># number of different prot in train</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb_prot</span><span class="p">):</span>

        <span class="n">j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">Mm</span><span class="p">)</span> <span class="c1"># choose protein with the maximum of interactions in the train</span>

        <span class="n">indice_P</span> <span class="o">=</span> <span class="n">Jm</span><span class="p">[</span><span class="n">train_index</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Ip</span><span class="p">[</span><span class="n">train_index</span><span class="p">]</span><span class="o">==</span><span class="n">j</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span>  <span class="c1">#np.array with index of interactions + in train</span>
        <span class="n">indice_N</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">Jm</span><span class="p">[</span><span class="n">train_index</span><span class="p">]</span> <span class="k">if</span> <span class="n">intMat</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">indice_NK</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">Jm</span><span class="p">[</span><span class="n">train_index</span><span class="p">]</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">intMat</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">])]</span> <span class="c1">#np.array  with index of interactions not known</span>

        <span class="n">indice_freq_mol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Mp</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1">#drug&#39;s index with more than 2 interactions +</span>
        <span class="n">indice_poss_mol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Mp</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1">#drug&#39;s index with 1 interaction +</span>

        <span class="n">indice_freq_one_prot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">indice_N</span><span class="p">,</span> <span class="n">indice_freq_mol</span><span class="p">)</span>
        <span class="n">indice_poss_one_prot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">indice_N</span><span class="p">,</span> <span class="n">indice_poss_mol</span><span class="p">)</span>

        <span class="n">nb_positive_interactions</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_P</span><span class="p">)</span>
        <span class="n">nb_frequent_hitters_negative_interactions</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_freq_one_prot</span><span class="p">)</span>

        <span class="n">indice_freq_one_prot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">indice_N</span><span class="p">,</span> <span class="n">indice_freq_mol</span><span class="p">)</span>
        <span class="n">indice_poss_one_prot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">indice_N</span><span class="p">,</span> <span class="n">indice_poss_mol</span><span class="p">)</span>
        <span class="n">indice_freq_one_prot_NK</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">indice_NK</span><span class="p">,</span> <span class="n">indice_freq_mol</span><span class="p">)</span>
        <span class="n">indice_poss_one_prot_NK</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">indice_NK</span><span class="p">,</span> <span class="n">indice_poss_mol</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_P</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_freq_one_prot</span><span class="p">):</span>
            <span class="c1"># we shoot at random nb_positive_interactions in drugs with a lot of interactions</span>
            <span class="n">indice_N_one_prot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">indice_freq_one_prot</span><span class="p">,</span>
                                                <span class="nb">len</span><span class="p">(</span><span class="n">indice_P</span><span class="p">),</span> <span class="n">replace</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_P</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_freq_one_prot</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_poss_one_prot</span><span class="p">):</span>
            <span class="c1"># we shoot at random nb_positive_interactions in drugs with a lot of interactions</span>
            <span class="n">nb_negative_interactions_remaining</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_P</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_freq_one_prot</span><span class="p">)</span>
            <span class="n">indice_N_one_prot_poss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">indice_poss_one_prot</span><span class="p">,</span>
                                                    <span class="n">nb_negative_interactions_remaining</span><span class="p">,</span> <span class="n">replace</span> <span class="o">=</span> <span class="kc">False</span> <span class="p">)</span>
            <span class="n">indice_N_one_prot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">indice_freq_one_prot</span><span class="p">,</span>
                                            <span class="n">indice_N_one_prot_poss</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_P</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_freq_one_prot</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_poss_one_prot</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_freq_one_prot_NK</span><span class="p">):</span>
            <span class="c1"># we shoot at random nb_positive_interactions in drugs with a lot of interactions</span>
            <span class="n">nb_negative_interactions_remaining</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_P</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_freq_one_prot</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_poss_one_prot</span><span class="p">)</span>
            <span class="n">indice_N_one_prot_poss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">indice_freq_one_prot_NK</span><span class="p">,</span>
                                                    <span class="n">nb_negative_interactions_remaining</span><span class="p">,</span> <span class="n">replace</span> <span class="o">=</span> <span class="kc">False</span> <span class="p">)</span>
            <span class="n">indice_N_one_prot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">indice_freq_one_prot</span><span class="p">,</span>
                                            <span class="n">indice_poss_one_prot</span><span class="p">,</span> <span class="n">indice_N_one_prot_poss</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># we shoot at random nb_positive_interactions in drugs with a lot of interactions</span>
            <span class="n">nb_negative_interactions_remaining</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_P</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_freq_one_prot</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_poss_one_prot</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_freq_one_prot_NK</span><span class="p">)</span>
            <span class="c1">#print(&quot;nb_negative_interactions_remaining&quot;, nb_negative_interactions_remaining) # pas de solution...</span>
            <span class="c1">#print(indice_poss_one_prot_NK.shape)</span>
            <span class="n">indice_N_one_prot_poss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">indice_poss_one_prot_NK</span><span class="p">,</span>
                                                    <span class="n">nb_negative_interactions_remaining</span><span class="p">,</span> <span class="n">replace</span> <span class="o">=</span> <span class="kc">False</span> <span class="p">)</span>
            <span class="n">indice_N_one_prot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">indice_freq_one_prot</span><span class="p">,</span>
                                            <span class="n">indice_poss_one_prot</span><span class="p">,</span> <span class="n">indice_freq_one_prot_NK</span><span class="p">,</span> <span class="n">indice_N_one_prot_poss</span><span class="p">))</span>

        <span class="n">Mp</span><span class="p">[</span><span class="n">indice_N_one_prot</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)]</span><span class="o">-=</span><span class="mi">1</span>

        <span class="c1"># this protein has been processed</span>
        <span class="n">Mm</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">indice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">indice_P</span><span class="p">,</span><span class="n">indice_N_one_prot</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">etiquette</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">intMat</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">indice</span><span class="p">]]</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">indice</span><span class="p">,</span> <span class="n">etiquette</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="n">j</span><span class="p">,</span><span class="n">A</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">train</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">train</span><span class="p">,</span><span class="n">B</span><span class="p">))</span>

    <span class="n">train</span> <span class="o">=</span> <span class="n">train</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;train&quot;</span><span class="p">,</span> <span class="n">train</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1">##### TEST ####</span>
    <span class="c1"># interactions + in test</span>
    <span class="n">indice_P_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">Ip</span><span class="p">[</span><span class="n">test_index</span><span class="p">],</span><span class="n">Jm</span><span class="p">[</span><span class="n">test_index</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">test_index</span><span class="p">))]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;nb of interactions + in test&quot;</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">indice_P_t</span><span class="p">))</span>

    <span class="c1"># interactions - in test</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">Inp</span><span class="p">,</span><span class="n">Jnm</span><span class="p">]]</span> <span class="c1"># all the zeros in the matrix (and NK ?)</span>
    <span class="n">a1</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">train</span><span class="p">[:,:</span><span class="mi">2</span><span class="p">]</span>   <span class="c1"># all the interactions in the train</span>
    <span class="n">b1</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
    <span class="n">indice_N_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">a1</span> <span class="o">-</span> <span class="n">b1</span><span class="p">))</span><span class="c1">#[:indice_P_t.shape[0],:] # we keep the same number of interactions - than interactions + in test, choosing the 0 in the matrix</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;number of real interactions - in test&quot;</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">indice_N_t</span><span class="p">))</span>

    <span class="c1"># add interactions np.nan in test</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_N_t</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># initialization</span>
        <span class="n">indice_N_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">Inkp</span><span class="p">,</span><span class="n">Jnkm</span><span class="p">]]</span> <span class="c1"># all the np.nan in the matrix</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_N_t</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">indice_P_t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="c1"># we add some interactions - in test to have the same number of interactions + and - in test choose in the np.nan in the matrix</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_N_t</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">indice_P_t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">b1</span><span class="p">:</span>
                <span class="n">indice_N_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">indice_N_t</span><span class="p">,</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)))</span>
                <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># we drop the first row of indice_N_t if is [-1, -1]</span>
    <span class="k">if</span> <span class="n">indice_N_t</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">indice_N_t</span> <span class="o">=</span> <span class="n">indice_N_t</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span>

    <span class="n">indice_N_t</span> <span class="o">=</span> <span class="n">indice_N_t</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">indice_P_t</span><span class="p">),:]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;number of interactions - in test&quot;</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">indice_N_t</span><span class="p">))</span>
    <span class="c1"># we add the column of 0 for the etiquette</span>
    <span class="n">indice_N_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">indice_N_t</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indice_N_t</span><span class="p">))]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">indice_P_t</span><span class="p">,</span><span class="n">indice_N_t</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;test&quot;</span><span class="p">,</span> <span class="n">test</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1">##### VALIDATION ####</span>
    <span class="c1"># interactions + in val</span>
    <span class="n">indice_P_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">Ip</span><span class="p">[</span><span class="n">val_index</span><span class="p">],</span><span class="n">Jm</span><span class="p">[</span><span class="n">val_index</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">val_index</span><span class="p">))]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;nb of interactions + in val&quot;</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">indice_P_v</span><span class="p">))</span>

    <span class="c1"># interactions - in val</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">Inp</span><span class="p">,</span><span class="n">Jnm</span><span class="p">]]</span> <span class="c1"># all the zeros in the matrix (and NK ?)</span>
    <span class="n">a1</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">train</span><span class="p">[:,:</span><span class="mi">2</span><span class="p">]</span>   <span class="c1"># all the interactions in the train</span>
    <span class="n">b1</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">test</span><span class="p">[:,:</span><span class="mi">2</span><span class="p">]</span>   <span class="c1"># all the interactions in the test</span>
    <span class="n">c1</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span>
    <span class="n">indice_N_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">a1</span> <span class="o">-</span> <span class="n">b1</span> <span class="o">-</span> <span class="n">c1</span><span class="p">))</span><span class="c1">#[:indice_P_v.shape[0],:] # we keep the same number of interactions - than interactions + in test, choosing the 0 in the matrix</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;number of real interactions - in val&quot;</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">indice_N_v</span><span class="p">))</span>

    <span class="c1"># add interactions np.nan in val</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_N_v</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># initialization</span>
        <span class="n">indice_N_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">Inkp</span><span class="p">,</span><span class="n">Jnkm</span><span class="p">]]</span> <span class="c1"># all the np.nan in the matrix</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_N_v</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">indice_P_v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="c1"># we add some interactions - in val to have the same number of interactions + and - in val choose in the np.nan in the matrix</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_N_v</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">indice_P_v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">b1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">c1</span><span class="p">):</span>
                <span class="n">indice_N_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">indice_N_v</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)))</span>
                <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
    
    <span class="c1"># we drop the first row of indice_N_v if is [-1, -1]</span>
    <span class="k">if</span> <span class="n">indice_N_v</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">indice_N_v</span> <span class="o">=</span> <span class="n">indice_N_v</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span>

    <span class="n">indice_N_v</span> <span class="o">=</span> <span class="n">indice_N_v</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">indice_P_v</span><span class="p">),:]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;number of interactions - in val&quot;</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">indice_N_v</span><span class="p">))</span>
    <span class="c1"># we add the column of 0 for the etiquette</span>
    <span class="n">indice_N_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">indice_N_v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indice_N_v</span><span class="p">))]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">indice_P_v</span><span class="p">,</span><span class="n">indice_N_v</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;val&quot;</span><span class="p">,</span> <span class="n">val</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Train/test/val datasets prepared.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">train</span><span class="p">,</span><span class="n">test</span><span class="p">,</span><span class="n">val</span></div>

<div class="viewcode-block" id="make_train_test_val_S2"><a class="viewcode-back" href="../komet.html#komet.make_train_test_val_S2">[docs]</a><span class="k">def</span> <span class="nf">make_train_test_val_S2</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Splits the interaction data into distinct training, testing, and validation datasets,</span>
<span class="sd">    ensuring molecules in the test set are not in the training set and molecules in the validation set</span>
<span class="sd">    are not in the training set. It processes input data to form interaction matrices and categorizes</span>
<span class="sd">    these interactions into positive, negative, and unknown based on their presence, absence, or uncertainty in the dataset.</span>

<span class="sd">    :param df: The input data containing the columns &#39;indfasta&#39;, &#39;indsmiles&#39;, and &#39;score&#39;, representing interaction data between proteins and molecules.</span>
<span class="sd">    :type df: pandas.DataFrame</span>
<span class="sd">    :return: A tuple of numpy.ndarrays representing the training, testing, and validation datasets. Each set contains arrays of interactions labeled with indices and interaction scores, with drugs and proteins split according to specified criteria to ensure separation between training, testing, and validation sets.</span>
<span class="sd">    :rtype: tuple</span>

<span class="sd">    The function performs the following steps:</span>
<span class="sd">    - Convert the DataFrame to a numpy array of interaction scores.</span>
<span class="sd">    - Determine the unique proteins and drugs, assigning them to train, test, and validation groups based on specified proportions.</span>
<span class="sd">    - For each group, create datasets of positive and negative interactions, handling missing values as unknown interactions.</span>
<span class="sd">    - Ensure there is no overlap of molecules between the training set and either the testing or validation sets.</span>
<span class="sd">    - Return the prepared datasets for further processing or model training.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">try</span> <span class="p">:</span> 
        <span class="n">intMat</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">pivot</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="s1">&#39;indfasta&#39;</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="s2">&quot;indsmiles&quot;</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="s1">&#39;score&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float16</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">intMat</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">pivot_table</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="s1">&#39;indfasta&#39;</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="s2">&quot;indsmiles&quot;</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="s1">&#39;score&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float16</span><span class="p">)</span>

    <span class="n">n_p</span><span class="p">,</span><span class="n">n_m</span> <span class="o">=</span> <span class="n">intMat</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">Ip</span><span class="p">,</span> <span class="n">Jm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">intMat</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># interactions + in train</span>
    <span class="n">Inp</span><span class="p">,</span> <span class="n">Jnm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">intMat</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># interactions - in train</span>
    <span class="n">Inkp</span><span class="p">,</span> <span class="n">Jnkm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">intMat</span><span class="p">))</span> <span class="c1"># interactions np.nan in train</span>


    <span class="n">nP</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="s2">&quot;indfasta&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">nM</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="s2">&quot;indsmiles&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">SP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">nP</span><span class="p">)</span>
    <span class="n">SM</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">nM</span><span class="p">)</span>

    <span class="n">groups</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ip</span><span class="p">,</span><span class="n">im</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">Ip</span><span class="p">,</span><span class="n">Jm</span><span class="p">):</span>
        <span class="k">if</span>  <span class="p">(</span><span class="n">im</span> <span class="ow">in</span> <span class="n">SM</span><span class="p">[:</span><span class="nb">int</span><span class="p">(</span><span class="mf">0.78</span><span class="o">*</span><span class="n">nM</span><span class="p">)]):</span>
            <span class="n">groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;train&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">im</span> <span class="ow">in</span> <span class="n">SM</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="mf">0.78</span><span class="o">*</span><span class="n">nM</span><span class="p">):</span><span class="nb">int</span><span class="p">(</span><span class="mf">0.92</span><span class="o">*</span><span class="n">nM</span><span class="p">)]):</span>
            <span class="n">groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;test&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">im</span> <span class="ow">in</span> <span class="n">SM</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="mf">0.92</span><span class="o">*</span><span class="n">nM</span><span class="p">):]):</span>
            <span class="n">groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;val&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;other&quot;</span><span class="p">)</span>

    <span class="n">train_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">groups</span><span class="p">)</span><span class="o">==</span><span class="s2">&quot;train&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">test_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">groups</span><span class="p">)</span><span class="o">==</span><span class="s2">&quot;test&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">val_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">groups</span><span class="p">)</span><span class="o">==</span><span class="s2">&quot;val&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1">#### TRAIN ####</span>
    <span class="n">Mm</span><span class="p">,</span> <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">Ip</span><span class="p">[</span><span class="n">train_index</span><span class="p">],</span> <span class="n">bins</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_p</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="c1"># np.array with  #interactions for each protein of the train at the beginning</span>
    <span class="n">Mp</span><span class="p">,</span> <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">Jm</span><span class="p">[</span><span class="n">train_index</span><span class="p">],</span> <span class="n">bins</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_m</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="c1"># np.array with  #interactions for each drugs at the beginning (how manu time it can be chosen)</span>

    <span class="n">train</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="n">nb_prot</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">Ip</span><span class="p">[</span><span class="n">train_index</span><span class="p">])))</span> <span class="c1"># number of different prot in train</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb_prot</span><span class="p">):</span>

        <span class="n">j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">Mm</span><span class="p">)</span> <span class="c1"># choose protein with the maximum of interactions in the train</span>

        <span class="n">indice_P</span> <span class="o">=</span> <span class="n">Jm</span><span class="p">[</span><span class="n">train_index</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Ip</span><span class="p">[</span><span class="n">train_index</span><span class="p">]</span><span class="o">==</span><span class="n">j</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span>  <span class="c1">#np.array with index of interactions + in train</span>
        <span class="n">indice_N</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">Jm</span><span class="p">[</span><span class="n">train_index</span><span class="p">]</span> <span class="k">if</span> <span class="n">intMat</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">indice_NK</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">Jm</span><span class="p">[</span><span class="n">train_index</span><span class="p">]</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">intMat</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">])]</span> <span class="c1">#np.array  with index of interactions not known</span>

        <span class="n">indice_freq_mol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Mp</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1">#drug&#39;s index with more than 2 interactions +</span>
        <span class="n">indice_poss_mol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Mp</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1">#drug&#39;s index with 1 interaction +</span>

        <span class="n">indice_freq_one_prot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">indice_N</span><span class="p">,</span> <span class="n">indice_freq_mol</span><span class="p">)</span>
        <span class="n">indice_poss_one_prot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">indice_N</span><span class="p">,</span> <span class="n">indice_poss_mol</span><span class="p">)</span>

        <span class="n">nb_positive_interactions</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_P</span><span class="p">)</span>
        <span class="n">nb_frequent_hitters_negative_interactions</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_freq_one_prot</span><span class="p">)</span>

        <span class="n">indice_freq_one_prot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">indice_N</span><span class="p">,</span> <span class="n">indice_freq_mol</span><span class="p">)</span>
        <span class="n">indice_poss_one_prot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">indice_N</span><span class="p">,</span> <span class="n">indice_poss_mol</span><span class="p">)</span>
        <span class="n">indice_freq_one_prot_NK</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">indice_NK</span><span class="p">,</span> <span class="n">indice_freq_mol</span><span class="p">)</span>
        <span class="n">indice_poss_one_prot_NK</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">indice_NK</span><span class="p">,</span> <span class="n">indice_poss_mol</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_P</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_freq_one_prot</span><span class="p">):</span>
            <span class="c1"># we shoot at random interactions - for drugs with a lot of interactions +</span>
            <span class="n">indice_N_one_prot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">indice_freq_one_prot</span><span class="p">,</span>
                                                <span class="nb">len</span><span class="p">(</span><span class="n">indice_P</span><span class="p">),</span> <span class="n">replace</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_P</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_freq_one_prot</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_poss_one_prot</span><span class="p">):</span>
            <span class="c1"># we shoot at random interactions - for drugs with 1 interaction +</span>
            <span class="n">nb_negative_interactions_remaining</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_P</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_freq_one_prot</span><span class="p">)</span>
            <span class="n">indice_N_one_prot_poss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">indice_poss_one_prot</span><span class="p">,</span>
                                                    <span class="n">nb_negative_interactions_remaining</span><span class="p">,</span> <span class="n">replace</span> <span class="o">=</span> <span class="kc">False</span> <span class="p">)</span>
            <span class="n">indice_N_one_prot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">indice_freq_one_prot</span><span class="p">,</span>
                                            <span class="n">indice_N_one_prot_poss</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_P</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_freq_one_prot</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_poss_one_prot</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_freq_one_prot_NK</span><span class="p">):</span>
            <span class="c1"># we shoot at random interactions np.nan for drugs with a lot of interactions +</span>
            <span class="n">nb_negative_interactions_remaining</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_P</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_freq_one_prot</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_poss_one_prot</span><span class="p">)</span>
            <span class="n">indice_N_one_prot_poss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">indice_freq_one_prot_NK</span><span class="p">,</span>
                                                    <span class="n">nb_negative_interactions_remaining</span><span class="p">,</span> <span class="n">replace</span> <span class="o">=</span> <span class="kc">False</span> <span class="p">)</span>
            <span class="n">indice_N_one_prot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">indice_freq_one_prot</span><span class="p">,</span>
                                            <span class="n">indice_poss_one_prot</span><span class="p">,</span> <span class="n">indice_N_one_prot_poss</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># we shoot at random interactions np.nan for drugs with 1 interaction +</span>
            <span class="n">nb_negative_interactions_remaining</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_P</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_freq_one_prot</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_poss_one_prot</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_freq_one_prot_NK</span><span class="p">)</span>
            <span class="c1">#print(&quot;nb_negative_interactions_remaining&quot;, nb_negative_interactions_remaining) </span>
            <span class="c1">#print(indice_poss_one_prot_NK.shape)</span>
            <span class="n">indice_N_one_prot_poss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">indice_poss_one_prot_NK</span><span class="p">,</span>
                                                    <span class="n">nb_negative_interactions_remaining</span><span class="p">,</span> <span class="n">replace</span> <span class="o">=</span> <span class="kc">False</span> <span class="p">)</span>
            <span class="n">indice_N_one_prot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">indice_freq_one_prot</span><span class="p">,</span>
                                            <span class="n">indice_poss_one_prot</span><span class="p">,</span> <span class="n">indice_freq_one_prot_NK</span><span class="p">,</span> <span class="n">indice_N_one_prot_poss</span><span class="p">))</span>

        <span class="n">Mp</span><span class="p">[</span><span class="n">indice_N_one_prot</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)]</span><span class="o">-=</span><span class="mi">1</span>

        <span class="c1"># this protein has been processed</span>
        <span class="n">Mm</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">indice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">indice_P</span><span class="p">,</span><span class="n">indice_N_one_prot</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">etiquette</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">intMat</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">indice</span><span class="p">]]</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">indice</span><span class="p">,</span> <span class="n">etiquette</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="n">j</span><span class="p">,</span><span class="n">A</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">train</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">train</span><span class="p">,</span><span class="n">B</span><span class="p">))</span>

    <span class="n">train</span> <span class="o">=</span> <span class="n">train</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;train&quot;</span><span class="p">,</span> <span class="n">train</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1">##### TEST ####</span>
    <span class="c1"># interactions + in test</span>
    <span class="n">indice_P_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">Ip</span><span class="p">[</span><span class="n">test_index</span><span class="p">],</span><span class="n">Jm</span><span class="p">[</span><span class="n">test_index</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">test_index</span><span class="p">))]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;nb of interactions + in test&quot;</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">indice_P_t</span><span class="p">))</span>
    <span class="n">I_t</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">elt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">indice_P_t</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">train</span> <span class="k">if</span> <span class="n">elt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;number of interactions + deleted in test&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">I_t</span><span class="p">)))</span>
    <span class="n">indice_P_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">indice_P_t</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">I_t</span><span class="p">))</span> <span class="p">,</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;number of interactions + in test&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_P_t</span><span class="p">))</span>

    <span class="c1"># interactions - in test</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">Inp</span><span class="p">,</span><span class="n">Jnm</span><span class="p">]]</span> <span class="c1"># all the zeros in the matrix</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;number of interactions -&quot;</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">indice_N_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">S_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">S_a</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="o">//</span><span class="mi">3</span><span class="p">]:</span>
        <span class="k">if</span>  <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">train</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]):</span> <span class="c1"># we drop the interactions- in train and the prot in train</span>
            <span class="n">indice_N_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">indice_N_t</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_N_t</span><span class="p">)</span> <span class="o">==</span> <span class="n">indice_P_t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">i_end_a</span> <span class="o">=</span> <span class="n">i</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;i_end&quot;</span><span class="p">,</span> <span class="n">i_end_a</span><span class="p">)</span>
            <span class="k">break</span>
    
    <span class="c1"># add interactions np.nan in test</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">Inkp</span><span class="p">,</span><span class="n">Jnkm</span><span class="p">]]</span> <span class="c1"># all the np.nan in the matrix</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;number of np.nan&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">S_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">S_c</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">train</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]):</span> <span class="c1"># we drop the interactions- in train and the prot in train</span>
            <span class="n">indice_N_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">indice_N_t</span><span class="p">,</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_N_t</span><span class="p">)</span> <span class="o">==</span> <span class="n">indice_P_t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">i_end_c</span> <span class="o">=</span> <span class="n">i</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;i_end&quot;</span><span class="p">,</span> <span class="n">i_end_c</span><span class="p">)</span>
            <span class="k">break</span>

    <span class="n">indice_N_t</span> <span class="o">=</span> <span class="n">indice_N_t</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">indice_P_t</span><span class="p">),:]</span> <span class="c1">#</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;number of interactions - in test&quot;</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">indice_N_t</span><span class="p">))</span>
    <span class="c1"># we add the column of 0 for the etiquette</span>
    <span class="n">indice_N_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">indice_N_t</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indice_N_t</span><span class="p">))]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">indice_P_t</span><span class="p">,</span><span class="n">indice_N_t</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;test&quot;</span><span class="p">,</span> <span class="n">test</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1">##### VALIDATION ####</span>
    <span class="c1"># interactions + in val</span>
    <span class="n">indice_P_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">Ip</span><span class="p">[</span><span class="n">val_index</span><span class="p">],</span><span class="n">Jm</span><span class="p">[</span><span class="n">val_index</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">val_index</span><span class="p">))]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;nb of interactions + in val&quot;</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">indice_P_v</span><span class="p">))</span>
    <span class="n">I_v</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">elt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">indice_P_v</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">train</span> <span class="k">if</span> <span class="n">elt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;number of interactions + deleted in test&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">I_v</span><span class="p">)))</span>
    <span class="n">indice_P_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">indice_P_v</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">I_v</span><span class="p">))</span> <span class="p">,</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;number of interactions + in test&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_P_v</span><span class="p">))</span>

    <span class="c1"># interactions - in val</span>
    <span class="n">indice_N_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">i_end_a</span> <span class="o">=</span> <span class="n">i_end_a</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">i_end_a</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="o">//</span><span class="mi">3</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">S_a</span><span class="p">[</span><span class="n">i_end_a</span><span class="o">+</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">train</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]):</span> <span class="c1"># we drop the interactions- in train and the prot in train</span>
            <span class="n">indice_N_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">indice_N_v</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_N_v</span><span class="p">)</span> <span class="o">==</span> <span class="n">indice_P_v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">i_end_a</span> <span class="o">=</span> <span class="n">i</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;i_end&quot;</span><span class="p">,</span> <span class="n">i_end_a</span><span class="p">)</span>
            <span class="k">break</span>

    <span class="c1"># add interactions np.nan in val</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_N_v</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># initialization</span>
        <span class="n">indice_N_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">S_c</span><span class="p">[</span><span class="n">i_end_c</span><span class="o">+</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="k">if</span>  <span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">train</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]):</span> <span class="c1">#we drop the interactions- in train and the prot in train</span>
            <span class="n">indice_N_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">indice_N_v</span><span class="p">,</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_N_v</span><span class="p">)</span> <span class="o">==</span> <span class="n">indice_P_v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;i_end_val&quot;</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
            <span class="k">break</span>
    
    <span class="c1"># we drop the first row of indice_N_v if is [-1, -1]</span>
    <span class="k">if</span> <span class="n">indice_N_v</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">indice_N_v</span> <span class="o">=</span> <span class="n">indice_N_v</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span>

    <span class="n">indice_N_v</span> <span class="o">=</span> <span class="n">indice_N_v</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">indice_P_v</span><span class="p">),:]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;number of interactions - in val&quot;</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">indice_N_v</span><span class="p">))</span>
    <span class="c1"># we add the column of 0 for the etiquette</span>
    <span class="n">indice_N_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">indice_N_v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indice_N_v</span><span class="p">))]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">indice_P_v</span><span class="p">,</span><span class="n">indice_N_v</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;val&quot;</span><span class="p">,</span> <span class="n">val</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Train/test/val datasets prepared.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">train</span><span class="p">,</span><span class="n">test</span><span class="p">,</span><span class="n">val</span></div>

<div class="viewcode-block" id="make_train_test_val_S3"><a class="viewcode-back" href="../komet.html#komet.make_train_test_val_S3">[docs]</a><span class="k">def</span> <span class="nf">make_train_test_val_S3</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Splits the interaction matrix into training, testing, and validation sets, ensuring there is no overlap</span>
<span class="sd">    between the proteins in the training set and those in the testing or validation sets. The split is based</span>
<span class="sd">    on the initial distribution of proteins and molecules in the interaction matrix.</span>

<span class="sd">    :param df: The input DataFrame containing the columns &#39;indfasta&#39; for proteins, &#39;indsmiles&#39; for molecules, and &#39;score&#39; for their interaction scores.</span>
<span class="sd">    :type df: pandas.DataFrame</span>
<span class="sd">    :return: A tuple containing the training, testing, and validation sets, each as a numpy.ndarray with the first column representing the index of proteins, the second column the index of molecules, and the third column the interaction scores (1 for interaction, 0 for no interaction, and np.nan for unknown interactions).</span>
<span class="sd">    :rtype: tuple</span>

<span class="sd">    The function performs the following operations:</span>
<span class="sd">    - Converts the DataFrame to a numpy array representing the interaction scores.</span>
<span class="sd">    - Randomly shuffles and splits proteins and molecules into distinct groups for training, testing, and validation based on predefined ratios.</span>
<span class="sd">    - Creates interaction datasets for each set, ensuring proteins in the test set are not in the train set, and proteins in the val set are not in the train set, thereby preventing data leakage.</span>
<span class="sd">    - Handles missing values and ensures the final datasets are balanced in terms of positive and negative interactions.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">try</span> <span class="p">:</span> 
        <span class="n">intMat</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">pivot</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="s1">&#39;indfasta&#39;</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="s2">&quot;indsmiles&quot;</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="s1">&#39;score&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float16</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">intMat</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">pivot_table</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="s1">&#39;indfasta&#39;</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="s2">&quot;indsmiles&quot;</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="s1">&#39;score&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float16</span><span class="p">)</span>

    <span class="n">n_p</span><span class="p">,</span><span class="n">n_m</span> <span class="o">=</span> <span class="n">intMat</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">Ip</span><span class="p">,</span> <span class="n">Jm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">intMat</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># interactions + in train</span>
    <span class="n">Inp</span><span class="p">,</span> <span class="n">Jnm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">intMat</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># interactions - in train</span>
    <span class="n">Inkp</span><span class="p">,</span> <span class="n">Jnkm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">intMat</span><span class="p">))</span> <span class="c1"># interactions np.nan in train</span>


    <span class="n">nP</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="s2">&quot;indfasta&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">nM</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="s2">&quot;indsmiles&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">SP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">nP</span><span class="p">)</span>
    <span class="n">SM</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">nM</span><span class="p">)</span>

    <span class="n">groups</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ip</span><span class="p">,</span><span class="n">im</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">Ip</span><span class="p">,</span><span class="n">Jm</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ip</span> <span class="ow">in</span> <span class="n">SP</span><span class="p">[:</span><span class="nb">int</span><span class="p">(</span><span class="mf">0.74</span><span class="o">*</span><span class="n">nP</span><span class="p">)]):</span>
            <span class="n">groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;train&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">ip</span> <span class="ow">in</span> <span class="n">SP</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="mf">0.74</span><span class="o">*</span><span class="n">nP</span><span class="p">):</span><span class="nb">int</span><span class="p">(</span><span class="mf">0.915</span><span class="o">*</span><span class="n">nP</span><span class="p">)]):</span>
            <span class="n">groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;test&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">ip</span> <span class="ow">in</span> <span class="n">SP</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="mf">0.915</span><span class="o">*</span><span class="n">nP</span><span class="p">):]):</span>
            <span class="n">groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;val&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;other&quot;</span><span class="p">)</span>

    <span class="n">train_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">groups</span><span class="p">)</span><span class="o">==</span><span class="s2">&quot;train&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">test_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">groups</span><span class="p">)</span><span class="o">==</span><span class="s2">&quot;test&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">val_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">groups</span><span class="p">)</span><span class="o">==</span><span class="s2">&quot;val&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>


    
    <span class="c1">#### TRAIN ####</span>
    <span class="n">Mm</span><span class="p">,</span> <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">Ip</span><span class="p">[</span><span class="n">train_index</span><span class="p">],</span> <span class="n">bins</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_p</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="c1"># np.array with  #interactions for each protein of the train at the beginning</span>
    <span class="n">Mp</span><span class="p">,</span> <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">Jm</span><span class="p">[</span><span class="n">train_index</span><span class="p">],</span> <span class="n">bins</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_m</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="c1"># np.array with  #interactions for each drugs at the beginning (how manu time it can be chosen)</span>

    <span class="n">train</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="n">nb_prot</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">Ip</span><span class="p">[</span><span class="n">train_index</span><span class="p">])))</span> <span class="c1"># number of different prot in train</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb_prot</span><span class="p">):</span>

        <span class="n">j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">Mm</span><span class="p">)</span> <span class="c1"># choose protein with the maximum of interactions in the train</span>

        <span class="n">indice_P</span> <span class="o">=</span> <span class="n">Jm</span><span class="p">[</span><span class="n">train_index</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Ip</span><span class="p">[</span><span class="n">train_index</span><span class="p">]</span><span class="o">==</span><span class="n">j</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span>  <span class="c1">#np.array with index of interactions + in train</span>
        <span class="n">indice_N</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">Jm</span><span class="p">[</span><span class="n">train_index</span><span class="p">]</span> <span class="k">if</span> <span class="n">intMat</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">indice_NK</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">Jm</span><span class="p">[</span><span class="n">train_index</span><span class="p">]</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">intMat</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">])]</span> <span class="c1">#np.array  with index of interactions not known</span>

        <span class="n">indice_freq_mol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Mp</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1">#drug&#39;s index with more than 2 interactions +</span>
        <span class="n">indice_poss_mol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Mp</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1">#drug&#39;s index with 1 interaction +</span>

        <span class="n">indice_freq_one_prot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">indice_N</span><span class="p">,</span> <span class="n">indice_freq_mol</span><span class="p">)</span>
        <span class="n">indice_poss_one_prot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">indice_N</span><span class="p">,</span> <span class="n">indice_poss_mol</span><span class="p">)</span>

        <span class="n">nb_positive_interactions</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_P</span><span class="p">)</span>
        <span class="n">nb_frequent_hitters_negative_interactions</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_freq_one_prot</span><span class="p">)</span>

        <span class="n">indice_freq_one_prot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">indice_N</span><span class="p">,</span> <span class="n">indice_freq_mol</span><span class="p">)</span>
        <span class="n">indice_poss_one_prot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">indice_N</span><span class="p">,</span> <span class="n">indice_poss_mol</span><span class="p">)</span>
        <span class="n">indice_freq_one_prot_NK</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">indice_NK</span><span class="p">,</span> <span class="n">indice_freq_mol</span><span class="p">)</span>
        <span class="n">indice_poss_one_prot_NK</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">indice_NK</span><span class="p">,</span> <span class="n">indice_poss_mol</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_P</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_freq_one_prot</span><span class="p">):</span>
            <span class="c1"># we shoot at random interactions - for drugs with a lot of interactions +</span>
            <span class="n">indice_N_one_prot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">indice_freq_one_prot</span><span class="p">,</span>
                                                <span class="nb">len</span><span class="p">(</span><span class="n">indice_P</span><span class="p">),</span> <span class="n">replace</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_P</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_freq_one_prot</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_poss_one_prot</span><span class="p">):</span>
            <span class="c1"># we shoot at random interactions - for drugs with 1 interaction +</span>
            <span class="n">nb_negative_interactions_remaining</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_P</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_freq_one_prot</span><span class="p">)</span>
            <span class="n">indice_N_one_prot_poss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">indice_poss_one_prot</span><span class="p">,</span>
                                                    <span class="n">nb_negative_interactions_remaining</span><span class="p">,</span> <span class="n">replace</span> <span class="o">=</span> <span class="kc">False</span> <span class="p">)</span>
            <span class="n">indice_N_one_prot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">indice_freq_one_prot</span><span class="p">,</span>
                                            <span class="n">indice_N_one_prot_poss</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_P</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_freq_one_prot</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_poss_one_prot</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_freq_one_prot_NK</span><span class="p">):</span>
            <span class="c1"># we shoot at random interactions np.nan for drugs with a lot of interactions +</span>
            <span class="n">nb_negative_interactions_remaining</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_P</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_freq_one_prot</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_poss_one_prot</span><span class="p">)</span>
            <span class="n">indice_N_one_prot_poss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">indice_freq_one_prot_NK</span><span class="p">,</span>
                                                    <span class="n">nb_negative_interactions_remaining</span><span class="p">,</span> <span class="n">replace</span> <span class="o">=</span> <span class="kc">False</span> <span class="p">)</span>
            <span class="n">indice_N_one_prot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">indice_freq_one_prot</span><span class="p">,</span>
                                            <span class="n">indice_poss_one_prot</span><span class="p">,</span> <span class="n">indice_N_one_prot_poss</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># we shoot at random interactions np.nan for drugs with 1 interaction +</span>
            <span class="n">nb_negative_interactions_remaining</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_P</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_freq_one_prot</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_poss_one_prot</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_freq_one_prot_NK</span><span class="p">)</span>
            <span class="c1">#print(&quot;nb_negative_interactions_remaining&quot;, nb_negative_interactions_remaining) </span>
            <span class="c1">#print(indice_poss_one_prot_NK.shape)</span>
            <span class="n">indice_N_one_prot_poss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">indice_poss_one_prot_NK</span><span class="p">,</span>
                                                    <span class="n">nb_negative_interactions_remaining</span><span class="p">,</span> <span class="n">replace</span> <span class="o">=</span> <span class="kc">False</span> <span class="p">)</span>
            <span class="n">indice_N_one_prot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">indice_freq_one_prot</span><span class="p">,</span>
                                            <span class="n">indice_poss_one_prot</span><span class="p">,</span> <span class="n">indice_freq_one_prot_NK</span><span class="p">,</span> <span class="n">indice_N_one_prot_poss</span><span class="p">))</span>

        <span class="n">Mp</span><span class="p">[</span><span class="n">indice_N_one_prot</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)]</span><span class="o">-=</span><span class="mi">1</span>

        <span class="c1"># this protein has been processed</span>
        <span class="n">Mm</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">indice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">indice_P</span><span class="p">,</span><span class="n">indice_N_one_prot</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">etiquette</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">intMat</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">indice</span><span class="p">]]</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">indice</span><span class="p">,</span> <span class="n">etiquette</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="n">j</span><span class="p">,</span><span class="n">A</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">train</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">train</span><span class="p">,</span><span class="n">B</span><span class="p">))</span>

    <span class="n">train</span> <span class="o">=</span> <span class="n">train</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;train&quot;</span><span class="p">,</span> <span class="n">train</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1">##### TEST ####</span>
    <span class="c1"># interactions + in test</span>
    <span class="n">indice_P_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">Ip</span><span class="p">[</span><span class="n">test_index</span><span class="p">],</span><span class="n">Jm</span><span class="p">[</span><span class="n">test_index</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">test_index</span><span class="p">))]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;nb of interactions + in test&quot;</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">indice_P_t</span><span class="p">))</span>
    <span class="n">I_t</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">elt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">indice_P_t</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">train</span> <span class="k">if</span> <span class="n">elt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;number of interactions + deleted in test&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">I_t</span><span class="p">)))</span>
    <span class="n">indice_P_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">indice_P_t</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">I_t</span><span class="p">))</span> <span class="p">,</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;number of interactions + in test&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_P_t</span><span class="p">))</span>

    <span class="c1"># interactions - in test</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">Inp</span><span class="p">,</span><span class="n">Jnm</span><span class="p">]]</span> <span class="c1"># all the zeros in the matrix</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;number of interactions -&quot;</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">indice_N_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">S_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">S_a</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="o">//</span><span class="mi">3</span><span class="p">]:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">train</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]):</span> <span class="c1"># we drop the interactions- in train and the prot in train</span>
            <span class="n">indice_N_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">indice_N_t</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_N_t</span><span class="p">)</span> <span class="o">==</span> <span class="n">indice_P_t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">i_end_a</span> <span class="o">=</span> <span class="n">i</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;i_end&quot;</span><span class="p">,</span> <span class="n">i_end_a</span><span class="p">)</span>
            <span class="k">break</span>
    
    <span class="c1"># add interactions np.nan in test</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">Inkp</span><span class="p">,</span><span class="n">Jnkm</span><span class="p">]]</span> <span class="c1"># all the np.nan in the matrix</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;number of np.nan&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">S_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">S_c</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">train</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]):</span> <span class="c1"># we drop the interactions- in train and the prot in train</span>
            <span class="n">indice_N_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">indice_N_t</span><span class="p">,</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_N_t</span><span class="p">)</span> <span class="o">==</span> <span class="n">indice_P_t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">i_end_c</span> <span class="o">=</span> <span class="n">i</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;i_end&quot;</span><span class="p">,</span> <span class="n">i_end_c</span><span class="p">)</span>
            <span class="k">break</span>

    <span class="n">indice_N_t</span> <span class="o">=</span> <span class="n">indice_N_t</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">indice_P_t</span><span class="p">),:]</span> <span class="c1">#</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;number of interactions - in test&quot;</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">indice_N_t</span><span class="p">))</span>
    <span class="c1"># we add the column of 0 for the etiquette</span>
    <span class="n">indice_N_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">indice_N_t</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indice_N_t</span><span class="p">))]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">indice_P_t</span><span class="p">,</span><span class="n">indice_N_t</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;test&quot;</span><span class="p">,</span> <span class="n">test</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1">##### VALIDATION ####</span>
    <span class="c1"># interactions + in val</span>
    <span class="n">indice_P_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">Ip</span><span class="p">[</span><span class="n">val_index</span><span class="p">],</span><span class="n">Jm</span><span class="p">[</span><span class="n">val_index</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">val_index</span><span class="p">))]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;nb of interactions + in val&quot;</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">indice_P_v</span><span class="p">))</span>
    <span class="n">I_v</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">elt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">indice_P_v</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">train</span> <span class="k">if</span> <span class="n">elt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;number of interactions + deleted in test&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">I_v</span><span class="p">)))</span>
    <span class="n">indice_P_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">indice_P_v</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">I_v</span><span class="p">))</span> <span class="p">,</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;number of interactions + in test&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_P_v</span><span class="p">))</span>

    <span class="c1"># interactions - in val</span>
    <span class="n">indice_N_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">i_end_a</span> <span class="o">=</span> <span class="n">i_end_a</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">i_end_a</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="o">//</span><span class="mi">3</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">S_a</span><span class="p">[</span><span class="n">i_end_a</span><span class="o">+</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">train</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]):</span> <span class="c1"># we drop the interactions- in train and the prot in train</span>
            <span class="n">indice_N_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">indice_N_v</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_N_v</span><span class="p">)</span> <span class="o">==</span> <span class="n">indice_P_v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">i_end_a</span> <span class="o">=</span> <span class="n">i</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;i_end&quot;</span><span class="p">,</span> <span class="n">i_end_a</span><span class="p">)</span>
            <span class="k">break</span>

    <span class="c1"># add interactions np.nan in val</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_N_v</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># initialization</span>
        <span class="n">indice_N_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">S_c</span><span class="p">[</span><span class="n">i_end_c</span><span class="o">+</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">train</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]):</span> <span class="c1">#we drop the interactions- in train and the prot in train</span>
            <span class="n">indice_N_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">indice_N_v</span><span class="p">,</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_N_v</span><span class="p">)</span> <span class="o">==</span> <span class="n">indice_P_v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;i_end_val&quot;</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
            <span class="k">break</span>
    
    <span class="c1"># we drop the first row of indice_N_v if is [-1, -1]</span>
    <span class="k">if</span> <span class="n">indice_N_v</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">indice_N_v</span> <span class="o">=</span> <span class="n">indice_N_v</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span>

    <span class="n">indice_N_v</span> <span class="o">=</span> <span class="n">indice_N_v</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">indice_P_v</span><span class="p">),:]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;number of interactions - in val&quot;</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">indice_N_v</span><span class="p">))</span>
    <span class="c1"># we add the column of 0 for the etiquette</span>
    <span class="n">indice_N_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">indice_N_v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indice_N_v</span><span class="p">))]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">indice_P_v</span><span class="p">,</span><span class="n">indice_N_v</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;val&quot;</span><span class="p">,</span> <span class="n">val</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Train/test/val datasets prepared.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">train</span><span class="p">,</span><span class="n">test</span><span class="p">,</span><span class="n">val</span></div>


<div class="viewcode-block" id="make_train_test_val_S4"><a class="viewcode-back" href="../komet.html#komet.make_train_test_val_S4">[docs]</a><span class="k">def</span> <span class="nf">make_train_test_val_S4</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Splits the interaction matrix into balanced training, testing, and validation sets ensuring there is no </span>
<span class="sd">    overlap between the proteins and molecules in the training set compared to those in the testing and </span>
<span class="sd">    validation sets. This aims to create distinct and balanced sets for robust model evaluation.</span>

<span class="sd">    :param df: Input DataFrame containing interaction data with &#39;indfasta&#39; for proteins, &#39;indsmiles&#39; for molecules, </span>
<span class="sd">               and &#39;score&#39; for interaction scores.</span>
<span class="sd">    :type df: pandas.DataFrame</span>
<span class="sd">    :return: A tuple containing the training, testing, and validation datasets. Each dataset consists of a numpy array with three columns: protein indices, molecule indices, and interaction scores. The interaction scores are 1 for positive interactions, 0 for negative interactions, and np.nan for unknown interactions.</span>
<span class="sd">    :rtype: tuple</span>

<span class="sd">    The function executes the following major steps:</span>
<span class="sd">    - Converts the DataFrame to a numpy array to represent the interaction scores.</span>
<span class="sd">    - Splits proteins and molecules into distinct groups for training, testing, and validation based on predefined criteria, ensuring there&#39;s no overlap between the sets for proteins and molecules.</span>
<span class="sd">    - Constructs interaction datasets for each set by maintaining a balance between positive and negative interactions and properly handling unknown interactions.</span>
<span class="sd">    - Ensures the testing and validation sets are balanced and do not contain any proteins or molecules present in the training set, thus avoiding data leakage and ensuring the model&#39;s generalizability.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">try</span> <span class="p">:</span> 
        <span class="n">intMat</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">pivot</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="s1">&#39;indfasta&#39;</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="s2">&quot;indsmiles&quot;</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="s1">&#39;score&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float16</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">intMat</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">pivot_table</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="s1">&#39;indfasta&#39;</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="s2">&quot;indsmiles&quot;</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="s1">&#39;score&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float16</span><span class="p">)</span>

    <span class="n">n_p</span><span class="p">,</span><span class="n">n_m</span> <span class="o">=</span> <span class="n">intMat</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">Ip</span><span class="p">,</span> <span class="n">Jm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">intMat</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># interactions + in train</span>
    <span class="n">Inp</span><span class="p">,</span> <span class="n">Jnm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">intMat</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># interactions - in train</span>
    <span class="n">Inkp</span><span class="p">,</span> <span class="n">Jnkm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">intMat</span><span class="p">))</span> <span class="c1"># interactions np.nan in train</span>


    <span class="n">nP</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="s2">&quot;indfasta&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">nM</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="s2">&quot;indsmiles&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">SP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">nP</span><span class="p">)</span>
    <span class="n">SM</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">nM</span><span class="p">)</span>

    <span class="n">groups</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ip</span><span class="p">,</span><span class="n">im</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">Ip</span><span class="p">,</span><span class="n">Jm</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ip</span> <span class="ow">in</span> <span class="n">SP</span><span class="p">[:</span><span class="nb">int</span><span class="p">(</span><span class="mf">0.76</span><span class="o">*</span><span class="n">nP</span><span class="p">)])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">im</span> <span class="ow">in</span> <span class="n">SM</span><span class="p">[:</span><span class="nb">int</span><span class="p">(</span><span class="mf">0.4</span><span class="o">*</span><span class="n">nM</span><span class="p">)]):</span>
            <span class="n">groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;train&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">ip</span> <span class="ow">in</span> <span class="n">SP</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="mf">0.76</span><span class="o">*</span><span class="n">nP</span><span class="p">):</span><span class="nb">int</span><span class="p">(</span><span class="mf">0.9</span><span class="o">*</span><span class="n">nP</span><span class="p">)])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">im</span> <span class="ow">in</span> <span class="n">SM</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="mf">0.4</span><span class="o">*</span><span class="n">nM</span><span class="p">):</span><span class="nb">int</span><span class="p">(</span><span class="mf">0.75</span><span class="o">*</span><span class="n">nM</span><span class="p">)]):</span>
            <span class="n">groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;test&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">ip</span> <span class="ow">in</span> <span class="n">SP</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="mf">0.9</span><span class="o">*</span><span class="n">nP</span><span class="p">):])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">im</span> <span class="ow">in</span> <span class="n">SM</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="mf">0.75</span><span class="o">*</span><span class="n">nM</span><span class="p">):]):</span>
            <span class="n">groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;val&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;other&quot;</span><span class="p">)</span>

    <span class="n">train_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">groups</span><span class="p">)</span><span class="o">==</span><span class="s2">&quot;train&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">test_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">groups</span><span class="p">)</span><span class="o">==</span><span class="s2">&quot;test&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">val_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">groups</span><span class="p">)</span><span class="o">==</span><span class="s2">&quot;val&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>


    
    <span class="c1">#### TRAIN ####</span>
    <span class="n">Mm</span><span class="p">,</span> <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">Ip</span><span class="p">[</span><span class="n">train_index</span><span class="p">],</span> <span class="n">bins</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_p</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="c1"># np.array with  #interactions for each protein of the train at the beginning</span>
    <span class="n">Mp</span><span class="p">,</span> <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">Jm</span><span class="p">[</span><span class="n">train_index</span><span class="p">],</span> <span class="n">bins</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_m</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="c1"># np.array with  #interactions for each drugs at the beginning (how manu time it can be chosen)</span>

    <span class="n">train</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="n">nb_prot</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">Ip</span><span class="p">[</span><span class="n">train_index</span><span class="p">])))</span> <span class="c1"># number of different prot in train</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb_prot</span><span class="p">):</span>

        <span class="n">j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">Mm</span><span class="p">)</span> <span class="c1"># choose protein with the maximum of interactions in the train</span>

        <span class="n">indice_P</span> <span class="o">=</span> <span class="n">Jm</span><span class="p">[</span><span class="n">train_index</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Ip</span><span class="p">[</span><span class="n">train_index</span><span class="p">]</span><span class="o">==</span><span class="n">j</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span>  <span class="c1">#np.array with index of interactions + in train</span>
        <span class="n">indice_N</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">Jm</span><span class="p">[</span><span class="n">train_index</span><span class="p">]</span> <span class="k">if</span> <span class="n">intMat</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">indice_NK</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">Jm</span><span class="p">[</span><span class="n">train_index</span><span class="p">]</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">intMat</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">])]</span> <span class="c1">#np.array  with index of interactions not known</span>

        <span class="n">indice_freq_mol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Mp</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1">#drug&#39;s index with more than 2 interactions +</span>
        <span class="n">indice_poss_mol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Mp</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1">#drug&#39;s index with 1 interaction +</span>

        <span class="n">indice_freq_one_prot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">indice_N</span><span class="p">,</span> <span class="n">indice_freq_mol</span><span class="p">)</span>
        <span class="n">indice_poss_one_prot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">indice_N</span><span class="p">,</span> <span class="n">indice_poss_mol</span><span class="p">)</span>

        <span class="n">nb_positive_interactions</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_P</span><span class="p">)</span>
        <span class="n">nb_frequent_hitters_negative_interactions</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_freq_one_prot</span><span class="p">)</span>

        <span class="n">indice_freq_one_prot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">indice_N</span><span class="p">,</span> <span class="n">indice_freq_mol</span><span class="p">)</span>
        <span class="n">indice_poss_one_prot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">indice_N</span><span class="p">,</span> <span class="n">indice_poss_mol</span><span class="p">)</span>
        <span class="n">indice_freq_one_prot_NK</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">indice_NK</span><span class="p">,</span> <span class="n">indice_freq_mol</span><span class="p">)</span>
        <span class="n">indice_poss_one_prot_NK</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">indice_NK</span><span class="p">,</span> <span class="n">indice_poss_mol</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_P</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_freq_one_prot</span><span class="p">):</span>
            <span class="c1"># we shoot at random interactions - for drugs with a lot of interactions +</span>
            <span class="n">indice_N_one_prot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">indice_freq_one_prot</span><span class="p">,</span>
                                                <span class="nb">len</span><span class="p">(</span><span class="n">indice_P</span><span class="p">),</span> <span class="n">replace</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_P</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_freq_one_prot</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_poss_one_prot</span><span class="p">):</span>
            <span class="c1"># we shoot at random interactions - for drugs with 1 interaction +</span>
            <span class="n">nb_negative_interactions_remaining</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_P</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_freq_one_prot</span><span class="p">)</span>
            <span class="n">indice_N_one_prot_poss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">indice_poss_one_prot</span><span class="p">,</span>
                                                    <span class="n">nb_negative_interactions_remaining</span><span class="p">,</span> <span class="n">replace</span> <span class="o">=</span> <span class="kc">False</span> <span class="p">)</span>
            <span class="n">indice_N_one_prot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">indice_freq_one_prot</span><span class="p">,</span>
                                            <span class="n">indice_N_one_prot_poss</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_P</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_freq_one_prot</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_poss_one_prot</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_freq_one_prot_NK</span><span class="p">):</span>
            <span class="c1"># we shoot at random interactions np.nan for drugs with a lot of interactions +</span>
            <span class="n">nb_negative_interactions_remaining</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_P</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_freq_one_prot</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_poss_one_prot</span><span class="p">)</span>
            <span class="n">indice_N_one_prot_poss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">indice_freq_one_prot_NK</span><span class="p">,</span>
                                                    <span class="n">nb_negative_interactions_remaining</span><span class="p">,</span> <span class="n">replace</span> <span class="o">=</span> <span class="kc">False</span> <span class="p">)</span>
            <span class="n">indice_N_one_prot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">indice_freq_one_prot</span><span class="p">,</span>
                                            <span class="n">indice_poss_one_prot</span><span class="p">,</span> <span class="n">indice_N_one_prot_poss</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># we shoot at random interactions np.nan for drugs with 1 interaction +</span>
            <span class="n">nb_negative_interactions_remaining</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_P</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_freq_one_prot</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_poss_one_prot</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_freq_one_prot_NK</span><span class="p">)</span>
            <span class="c1">#print(&quot;nb_negative_interactions_remaining&quot;, nb_negative_interactions_remaining) </span>
            <span class="c1">#print(indice_poss_one_prot_NK.shape)</span>
            <span class="n">indice_N_one_prot_poss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">indice_poss_one_prot_NK</span><span class="p">,</span>
                                                    <span class="n">nb_negative_interactions_remaining</span><span class="p">,</span> <span class="n">replace</span> <span class="o">=</span> <span class="kc">False</span> <span class="p">)</span>
            <span class="n">indice_N_one_prot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">indice_freq_one_prot</span><span class="p">,</span>
                                            <span class="n">indice_poss_one_prot</span><span class="p">,</span> <span class="n">indice_freq_one_prot_NK</span><span class="p">,</span> <span class="n">indice_N_one_prot_poss</span><span class="p">))</span>

        <span class="n">Mp</span><span class="p">[</span><span class="n">indice_N_one_prot</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)]</span><span class="o">-=</span><span class="mi">1</span>

        <span class="c1"># this protein has been processed</span>
        <span class="n">Mm</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">indice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">indice_P</span><span class="p">,</span><span class="n">indice_N_one_prot</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">etiquette</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">intMat</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">indice</span><span class="p">]]</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">indice</span><span class="p">,</span> <span class="n">etiquette</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="n">j</span><span class="p">,</span><span class="n">A</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">train</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">train</span><span class="p">,</span><span class="n">B</span><span class="p">))</span>

    <span class="n">train</span> <span class="o">=</span> <span class="n">train</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;train&quot;</span><span class="p">,</span> <span class="n">train</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1">##### TEST ####</span>
    <span class="c1"># interactions + in test</span>
    <span class="n">indice_P_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">Ip</span><span class="p">[</span><span class="n">test_index</span><span class="p">],</span><span class="n">Jm</span><span class="p">[</span><span class="n">test_index</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">test_index</span><span class="p">))]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;nb of interactions + in test&quot;</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">indice_P_t</span><span class="p">))</span>
    <span class="n">I_t</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">elt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">indice_P_t</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">train</span> <span class="k">if</span> <span class="n">elt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">elt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;number of interactions + deleted in test&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">I_t</span><span class="p">)))</span>
    <span class="n">indice_P_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">indice_P_t</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">I_t</span><span class="p">))</span> <span class="p">,</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;number of interactions + in test&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_P_t</span><span class="p">))</span>

    <span class="c1"># interactions - in test</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">Inp</span><span class="p">,</span><span class="n">Jnm</span><span class="p">]]</span> <span class="c1"># all the zeros in the matrix</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;number of interactions -&quot;</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">indice_N_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">S_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">S_a</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="o">//</span><span class="mi">3</span><span class="p">]:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">train</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">train</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]):</span> <span class="c1"># we drop the interactions- in train and the prot in train</span>
            <span class="n">indice_N_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">indice_N_t</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_N_t</span><span class="p">)</span> <span class="o">==</span> <span class="n">indice_P_t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">i_end_a</span> <span class="o">=</span> <span class="n">i</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;i_end&quot;</span><span class="p">,</span> <span class="n">i_end_a</span><span class="p">)</span>
            <span class="k">break</span>
    
    <span class="c1"># add interactions np.nan in test</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">Inkp</span><span class="p">,</span><span class="n">Jnkm</span><span class="p">]]</span> <span class="c1"># all the np.nan in the matrix</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;number of np.nan&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">S_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">S_c</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">train</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">train</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]):</span> <span class="c1"># we drop the interactions- in train and the prot in train</span>
            <span class="n">indice_N_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">indice_N_t</span><span class="p">,</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_N_t</span><span class="p">)</span> <span class="o">==</span> <span class="n">indice_P_t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">i_end_c</span> <span class="o">=</span> <span class="n">i</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;i_end&quot;</span><span class="p">,</span> <span class="n">i_end_c</span><span class="p">)</span>
            <span class="k">break</span>

    <span class="n">indice_N_t</span> <span class="o">=</span> <span class="n">indice_N_t</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">indice_P_t</span><span class="p">),:]</span> <span class="c1">#</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;number of interactions - in test&quot;</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">indice_N_t</span><span class="p">))</span>
    <span class="c1"># we add the column of 0 for the etiquette</span>
    <span class="n">indice_N_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">indice_N_t</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indice_N_t</span><span class="p">))]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">indice_P_t</span><span class="p">,</span><span class="n">indice_N_t</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;test&quot;</span><span class="p">,</span> <span class="n">test</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1">##### VALIDATION ####</span>
    <span class="c1"># interactions + in val</span>
    <span class="n">indice_P_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">Ip</span><span class="p">[</span><span class="n">val_index</span><span class="p">],</span><span class="n">Jm</span><span class="p">[</span><span class="n">val_index</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">val_index</span><span class="p">))]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;nb of interactions + in val&quot;</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">indice_P_v</span><span class="p">))</span>
    <span class="n">I_v</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">elt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">indice_P_v</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">train</span> <span class="k">if</span> <span class="n">elt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">elt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;number of interactions + deleted in test&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">I_v</span><span class="p">)))</span>
    <span class="n">indice_P_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">indice_P_v</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">I_v</span><span class="p">))</span> <span class="p">,</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;number of interactions + in test&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_P_v</span><span class="p">))</span>

    <span class="c1"># interactions - in val</span>
    <span class="n">indice_N_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">i_end_a</span> <span class="o">=</span> <span class="n">i_end_a</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">i_end_a</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="o">//</span><span class="mi">3</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">S_a</span><span class="p">[</span><span class="n">i_end_a</span><span class="o">+</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">train</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">train</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]):</span> <span class="c1"># we drop the interactions- in train and the prot in train</span>
            <span class="n">indice_N_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">indice_N_v</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_N_v</span><span class="p">)</span> <span class="o">==</span> <span class="n">indice_P_v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">i_end_a</span> <span class="o">=</span> <span class="n">i</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;i_end&quot;</span><span class="p">,</span> <span class="n">i_end_a</span><span class="p">)</span>
            <span class="k">break</span>

    <span class="c1"># add interactions np.nan in val</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_N_v</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># initialization</span>
        <span class="n">indice_N_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">S_c</span><span class="p">[</span><span class="n">i_end_c</span><span class="o">+</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">train</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">train</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]):</span> <span class="c1">#we drop the interactions- in train and the prot in train</span>
            <span class="n">indice_N_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">indice_N_v</span><span class="p">,</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice_N_v</span><span class="p">)</span> <span class="o">==</span> <span class="n">indice_P_v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;i_end_val&quot;</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
            <span class="k">break</span>
    
    <span class="c1"># we drop the first row of indice_N_v if is [-1, -1]</span>
    <span class="k">if</span> <span class="n">indice_N_v</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">indice_N_v</span> <span class="o">=</span> <span class="n">indice_N_v</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span>

    <span class="n">indice_N_v</span> <span class="o">=</span> <span class="n">indice_N_v</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">indice_P_v</span><span class="p">),:]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;number of interactions - in val&quot;</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">indice_N_v</span><span class="p">))</span>
    <span class="c1"># we add the column of 0 for the etiquette</span>
    <span class="n">indice_N_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">indice_N_v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indice_N_v</span><span class="p">))]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">indice_P_v</span><span class="p">,</span><span class="n">indice_N_v</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;val&quot;</span><span class="p">,</span> <span class="n">val</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Train/test/val datasets prepared.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">train</span><span class="p">,</span><span class="n">test</span><span class="p">,</span><span class="n">val</span></div>

<div class="viewcode-block" id="process_LCIdb"><a class="viewcode-back" href="../komet.html#komet.process_LCIdb">[docs]</a><span class="k">def</span> <span class="nf">process_LCIdb</span><span class="p">(</span><span class="n">name_file</span><span class="p">,</span> <span class="n">data_dir</span> <span class="o">=</span> <span class="s2">&quot;./&quot;</span><span class="p">,</span> <span class="n">max_length_fasta</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">bioactivity_choice</span> <span class="o">=</span> <span class="s2">&quot;checkand1database&quot;</span><span class="p">,</span><span class="n">min_weight</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="n">max_weight</span> <span class="o">=</span> <span class="mi">900</span><span class="p">,</span>  <span class="n">interaction_plus</span> <span class="o">=</span> <span class="mf">1e-7</span><span class="p">,</span> <span class="n">interaction_minus</span> <span class="o">=</span> <span class="mf">1e-4</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Processes data from a given ligand-chemical interaction database file and performs various data cleaning and transformation steps.</span>

<span class="sd">    :param name_file: The name of the file containing the database information.</span>
<span class="sd">    :type name_file: str</span>
<span class="sd">    :param data_dir: The directory where the database file and the file prot_uniprot_fasta_all.csv are located, defaults to &quot;./&quot;.</span>
<span class="sd">    :type data_dir: str, optional</span>
<span class="sd">    :param max_length_fasta: The maximum length of FASTA sequences to be included, defaults to 1000.</span>
<span class="sd">    :type max_length_fasta: int, optional</span>
<span class="sd">    :param bioactivity_choice: The type of bioactivity data to include, defaults to &#39;checkand1database&#39;.</span>
<span class="sd">    :type bioactivity_choice: str, optional</span>
<span class="sd">    :param min_weight: The minimum molecular weight of the ligands to be included, defaults to 100.</span>
<span class="sd">    :type min_weight: int, optional</span>
<span class="sd">    :param max_weight: The maximum molecular weight of the ligands to be included, defaults to 900.</span>
<span class="sd">    :type max_weight: int, optional</span>
<span class="sd">    :param interaction_plus: The threshold for positive interaction, defaults to 1e-7.</span>
<span class="sd">    :type interaction_plus: float, optional</span>
<span class="sd">    :param interaction_minus: The threshold for negative interaction, defaults to 1e-4.</span>
<span class="sd">    :type interaction_minus: float, optional</span>

<span class="sd">    :returns: A pandas DataFrame containing the processed and filtered data.</span>
<span class="sd">    :rtype: pandas.DataFrame</span>

<span class="sd">    The function performs the following steps:</span>
<span class="sd">    - Reads the database and filters based on activity type (pIC50, pKd, pKi) and units (negative logarithm).</span>
<span class="sd">    - Merges with protein FASTA sequence data and filters based on sequence length and molecular weight.</span>
<span class="sd">    - Processes bioactivity data based on the selected type and calculates mean, min, and max bioactivity values.</span>
<span class="sd">    - Aggregates data based on SMILES representation and FASTA sequence, and calculates interaction scores.</span>
<span class="sd">    - Saves the processed data to a new CSV file.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># download</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">data_dir</span><span class="o">+</span><span class="n">name_file</span><span class="p">,</span><span class="n">low_memory</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;all&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;# Ligand names&quot;</span><span class="p">,</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;Ligand names&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;# targets&quot;</span><span class="p">,</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;Target&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1"># keep only pIC50, pKd and pKi</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[((</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;Activity type&quot;</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;pIC50&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;Activity type&quot;</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;pKd&#39;</span><span class="p">))</span> <span class="o">|</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;Activity type&quot;</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;pKi&#39;</span><span class="p">)</span>   <span class="p">]</span><span class="c1">#.dropna(axis = 1, how = &#39;all&#39;)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;pIC50, pKd and pKi&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;# Ligand names&quot;</span><span class="p">,</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;Ligand names&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;# targets&quot;</span><span class="p">,</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;Target&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1"># keep only ligns which the negative logarithm of the measure is known</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;Unit&quot;</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;neg. log&#39;</span><span class="p">]</span><span class="c1">#.dropna(axis = 1, how = &#39;all&#39;)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Unit neg. log&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;# Ligand names&quot;</span><span class="p">,</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;Ligand names&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;# targets&quot;</span><span class="p">,</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;Target&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1"># add uniprot,fasta for human proteins</span>
    <span class="n">df_hgnc_symbol_check</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">data_dir</span> <span class="o">+</span><span class="s1">&#39;prot_uniprot_fasta_all.csv&#39;</span><span class="p">)</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">df_hgnc_symbol_check</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;add uniprot,fasta&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;# Ligand names&quot;</span><span class="p">,</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;Ligand names&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;# fasta&quot;</span><span class="p">,</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;fasta&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1">#keep proteins with fasta length &lt; max_length_fasta</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;fasta&#39;</span><span class="p">]</span><span class="o">&lt;</span> <span class="n">max_length_fasta</span><span class="o">*</span><span class="s1">&#39;Z&#39;</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;fasta length &lt; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">max_length_fasta</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;# Ligand names&quot;</span><span class="p">,</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;Ligand names&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;# fasta&quot;</span><span class="p">,</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;fasta&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1">#bioactivity values;</span>
    <span class="k">if</span> <span class="n">bioactivity_choice</span> <span class="o">==</span> <span class="s1">&#39;check&#39;</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;Activity check annotation&quot;</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39; &#39;</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">bioactivity_choice</span> <span class="o">==</span> <span class="s1">&#39;check_and_1database&#39;</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;Activity check annotation&quot;</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39; &#39;</span><span class="p">)</span><span class="o">|</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;Activity check annotation&quot;</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;only 1 data point&#39;</span><span class="p">)]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Activity check annotation&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;# Ligand names&quot;</span><span class="p">,</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;Ligand names&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;# targets&quot;</span><span class="p">,</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;Target&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1"># keep only ligns which the Smiles is ckecked</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;Structure check (Tanimoto)&quot;</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;match&#39;</span><span class="p">)</span> <span class="o">|</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;Structure check (Tanimoto)&quot;</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;1 structure&#39;</span><span class="p">)</span> <span class="o">|</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;Structure check (Tanimoto)&quot;</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;no match (1)&#39;</span><span class="p">)</span> <span class="p">]</span><span class="c1">#.dropna(axis = 1, how = &#39;all&#39;)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Structure check (Tanimoto)&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;# Ligand names&quot;</span><span class="p">,</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;Ligand names&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;# fasta&quot;</span><span class="p">,</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;fasta&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1"># put index from 0 to len(df)</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># we keep one smiles for each lign</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="o">-</span><span class="mi">13</span><span class="p">,</span><span class="n">p</span><span class="o">-</span><span class="mi">8</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">],</span><span class="nb">str</span><span class="p">)</span> <span class="p">:</span>
                <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>

    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;smiles&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">))</span>

    <span class="c1"># keep molecule with mol weight (M) between 100 and 900</span>
    <span class="n">liste</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">cl</span> <span class="ow">in</span> <span class="n">df</span><span class="p">[[</span><span class="s2">&quot;smiles&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">cl</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
            <span class="n">mol_weight</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">MolWt</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
            <span class="n">liste</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mol_weight</span><span class="p">);</span>
        <span class="k">except</span> <span class="p">:</span>
            <span class="n">mol_weight</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">liste</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mol_weight</span><span class="p">)</span>

    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;mol_weight&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">liste</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;mol_weight&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">max_weight</span><span class="p">]</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;mol_weight&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">min_weight</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;mol_weight between </span><span class="si">{</span><span class="n">min_weight</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">max_weight</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;# smiles&quot;</span><span class="p">,</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;smiles&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;# fasta&quot;</span><span class="p">,</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;fasta&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1"># put index from 0 to len(df)</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># calculate the mean,min,max of the bioactivity</span>
    <span class="k">def</span> <span class="nf">catch</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">handle</span><span class="o">=</span><span class="k">lambda</span> <span class="n">e</span> <span class="p">:</span> <span class="n">e</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">l_m</span> <span class="o">=</span> <span class="p">[</span><span class="n">catch</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span><span class="nb">float</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]))</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="n">p</span><span class="o">-</span><span class="mi">18</span><span class="p">)]</span>
        <span class="c1"># quit np.nan of lm</span>
        <span class="n">l_m</span> <span class="o">=</span> <span class="p">[</span><span class="n">l_m</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">l_m</span><span class="p">))</span> <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">l_m</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)]</span>

        <span class="n">l_p</span> <span class="o">=</span> <span class="p">[</span><span class="n">catch</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span><span class="nb">float</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="n">p</span><span class="o">-</span><span class="mi">18</span><span class="p">)]</span>
        <span class="c1"># quit np.nan of lp</span>
        <span class="n">l_p</span> <span class="o">=</span> <span class="p">[</span><span class="n">l_p</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">l_p</span><span class="p">))</span> <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">l_p</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)]</span>

        <span class="c1"># calculate the ponderated mean of the bioactivity</span>
        <span class="n">m</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">l_m</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">l_p</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">l_m</span><span class="p">))])</span><span class="o">/</span><span class="nb">sum</span><span class="p">(</span><span class="n">l_p</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">m</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">l_m</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">l_m</span><span class="p">)</span>

    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;mean,min,max&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">))</span>

    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;mean&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span><span class="nb">float</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]),</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">))</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;min&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span><span class="nb">float</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]),</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">))</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;max&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">][</span><span class="mi">2</span><span class="p">]),</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">))</span>

    <span class="c1"># find column with (Ligand names,Target) and diferrent activity type (pKd, pKi, PIC50) and mean</span>
    <span class="n">aggregation_functions</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;ChEMBL ID&quot;</span> <span class="p">:</span> <span class="s1">&#39;first&#39;</span><span class="p">,</span><span class="s2">&quot;PubChem ID&quot;</span> <span class="p">:</span> <span class="s1">&#39;first&#39;</span><span class="p">,</span><span class="s2">&quot;IUPHAR ID&quot;</span> <span class="p">:</span> <span class="s1">&#39;first&#39;</span><span class="p">,</span> <span class="s2">&quot;Ligand names&quot;</span><span class="p">:</span><span class="s2">&quot;first&quot;</span><span class="p">,</span> <span class="s2">&quot;Target&quot;</span><span class="p">:</span><span class="s1">&#39;first&#39;</span><span class="p">,</span><span class="s2">&quot;uniprot&quot;</span><span class="p">:</span><span class="s1">&#39;first&#39;</span><span class="p">,</span> <span class="s2">&quot;mean&quot;</span><span class="p">:</span> <span class="s1">&#39;mean&#39;</span><span class="p">,</span><span class="s2">&quot;min&quot;</span><span class="p">:</span> <span class="s1">&#39;min&#39;</span><span class="p">,</span><span class="s2">&quot;max&quot;</span><span class="p">:</span> <span class="s1">&#39;max&#39;</span><span class="p">}</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s2">&quot;smiles&quot;</span><span class="p">,</span><span class="s1">&#39;fasta&#39;</span><span class="p">,</span><span class="s2">&quot;Activity type&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="n">aggregation_functions</span><span class="p">)</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>  <span class="c1">#pour enlever multi-index</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;agregation mean, min, max by smiles,fasta, activity type&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;# smiles&quot;</span><span class="p">,</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;smiles&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;# fasta&quot;</span><span class="p">,</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;fasta&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1"># make a column pIC50 with the &#39;mean&#39; if &quot;Activity type&quot; == pIC50</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;mean pIC50&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;mean&quot;</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;Activity type&quot;</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;pIC50&#39;</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;mean pKi&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;mean&quot;</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;Activity type&quot;</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;pKi&#39;</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;mean pKd&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;mean&quot;</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;Activity type&quot;</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;pKd&#39;</span><span class="p">)</span>

    <span class="c1"># replace 0 in  pIC50, pKi, pKd by nan</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;mean pIC50&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;mean pIC50&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;mean pKi&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;mean pKi&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;mean pKd&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;mean pKd&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

    <span class="c1"># make a column pIC50 with the &#39;min&#39; if &quot;Activity type&quot; == pIC50</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;min pIC50&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;min&quot;</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;Activity type&quot;</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;pIC50&#39;</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;min pKi&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;min&quot;</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;Activity type&quot;</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;pKi&#39;</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;min pKd&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;min&quot;</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;Activity type&quot;</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;pKd&#39;</span><span class="p">)</span>

    <span class="c1"># replace 0 in  pIC50, pKi, pKd by nan</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;min pIC50&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;min pIC50&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;min pKi&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;min pKi&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;min pKd&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;min pKd&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

    <span class="c1"># make a column pIC50 with the &#39;max&#39; if &quot;Activity type&quot; == pIC50</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;max pIC50&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;max&quot;</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;Activity type&quot;</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;pIC50&#39;</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;max pKi&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;max&quot;</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;Activity type&quot;</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;pKi&#39;</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;max pKd&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;max&quot;</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;Activity type&quot;</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;pKd&#39;</span><span class="p">)</span>

    <span class="c1"># replace 0 in  pIC50, pKi, pKd by nan</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;max pIC50&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;max pIC50&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;max pKi&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;max pKi&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;max pKd&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;max pKd&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

    <span class="c1"># find column with (Ligand names,Target) and diferrent activity type (pKd, pKi, PIC50) and mean</span>
    <span class="n">aggregation_functions</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;ChEMBL ID&quot;</span> <span class="p">:</span> <span class="s1">&#39;first&#39;</span><span class="p">,</span><span class="s2">&quot;PubChem ID&quot;</span> <span class="p">:</span> <span class="s1">&#39;first&#39;</span><span class="p">,</span><span class="s2">&quot;IUPHAR ID&quot;</span> <span class="p">:</span> <span class="s1">&#39;first&#39;</span><span class="p">,</span> <span class="s2">&quot;Ligand names&quot;</span><span class="p">:</span><span class="s2">&quot;first&quot;</span><span class="p">,</span> <span class="s2">&quot;Target&quot;</span><span class="p">:</span><span class="s1">&#39;first&#39;</span><span class="p">,</span><span class="s2">&quot;uniprot&quot;</span><span class="p">:</span><span class="s1">&#39;first&#39;</span><span class="p">,</span> 
                            <span class="s2">&quot;mean&quot;</span><span class="p">:</span> <span class="s1">&#39;mean&#39;</span><span class="p">,</span><span class="s2">&quot;mean pIC50&quot;</span><span class="p">:</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span><span class="s2">&quot;mean pKi&quot;</span><span class="p">:</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span><span class="s2">&quot;mean pKd&quot;</span><span class="p">:</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span> <span class="s2">&quot;min&quot;</span><span class="p">:</span> <span class="s1">&#39;min&#39;</span><span class="p">,</span><span class="s2">&quot;min pIC50&quot;</span><span class="p">:</span><span class="s2">&quot;min&quot;</span><span class="p">,</span><span class="s2">&quot;min pKi&quot;</span><span class="p">:</span><span class="s2">&quot;min&quot;</span><span class="p">,</span><span class="s2">&quot;min pKd&quot;</span><span class="p">:</span><span class="s2">&quot;min&quot;</span><span class="p">,</span><span class="s2">&quot;max&quot;</span><span class="p">:</span> <span class="s1">&#39;max&#39;</span><span class="p">,</span><span class="s2">&quot;max pIC50&quot;</span><span class="p">:</span><span class="s2">&quot;max&quot;</span><span class="p">,</span><span class="s2">&quot;max pKi&quot;</span><span class="p">:</span><span class="s2">&quot;max&quot;</span><span class="p">,</span><span class="s2">&quot;max pKd&quot;</span><span class="p">:</span><span class="s2">&quot;max&quot;</span><span class="p">}</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s2">&quot;smiles&quot;</span><span class="p">,</span><span class="s1">&#39;fasta&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="n">aggregation_functions</span><span class="p">)</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>  <span class="c1">#pour enlever multi-index</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;agregation mean, min, max by smiles,fasta&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;# smiles&quot;</span><span class="p">,</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;smiles&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;# fasta&quot;</span><span class="p">,</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;fasta&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="n">score_plus</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">interaction_plus</span><span class="p">)</span>
    <span class="n">score_minus</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">interaction_minus</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">calcul_score_mean</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">score_plus</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">score_minus</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.5</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">calcul_score_minMax</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">x</span><span class="p">):</span>
        <span class="n">m</span> <span class="o">=</span> <span class="s2">&quot;min &quot;</span><span class="o">+</span><span class="n">x</span>
        <span class="n">M</span> <span class="o">=</span> <span class="s2">&quot;max &quot;</span><span class="o">+</span><span class="n">x</span>
        <span class="k">if</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">m</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">score_plus</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">M</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">score_minus</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.5</span>

    <span class="k">def</span> <span class="nf">f_score</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
        <span class="c1"># If a given compound and protein target have multiple measurements of different types,</span>
        <span class="c1"># we choose them in the following order of preference: Kd over Ki over IC50.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="s2">&quot;mean pKd&quot;</span><span class="p">]):</span>
            <span class="k">return</span> <span class="n">calcul_score_mean</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="s2">&quot;mean pKd&quot;</span><span class="p">])</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="s2">&quot;mean pKi&quot;</span><span class="p">]):</span>
            <span class="k">return</span> <span class="n">calcul_score_mean</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="s2">&quot;mean pKi&quot;</span><span class="p">])</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="s2">&quot;mean pIC50&quot;</span><span class="p">]):</span>
            <span class="k">return</span> <span class="n">calcul_score_mean</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="s2">&quot;mean pIC50&quot;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="s2">&quot;min pKd&quot;</span><span class="p">]):</span>
                <span class="k">return</span> <span class="n">calcul_score_minMax</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="s2">&quot;pKd&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="s2">&quot;min pKi&quot;</span><span class="p">]):</span>
                <span class="k">return</span> <span class="n">calcul_score_minMax</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="s2">&quot;pKi&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="s2">&quot;min pIC50&quot;</span><span class="p">]):</span>
                <span class="k">return</span> <span class="n">calcul_score_minMax</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="s2">&quot;pIC50&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;score&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">f_score</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;score calcul&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;df.shape = &quot;</span><span class="p">,</span><span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1"># register the dataframe</span>
    <span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">data_dir</span><span class="o">+</span><span class="s2">&quot;LCIdb.csv&quot;</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Gwenn Guichaoua.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>